#!/usr/bin/env python3
"""
Chapter 1の全文翻訳（画像付き）を生成するスクリプト
"""

import os
from datetime import datetime

def translate_chapter1_with_images():
    """Chapter 1の全文翻訳（画像付き）"""
    content = r"""
        <h1>第1章：モデリングの力を解き放つ</h1>
        
        <div class="notice">
            <div class="notice-title">📖 この章について</div>
            <p>この内容は「Data Modeling with Snowflake」の第1章を、省略することなく完全に日本語に翻訳したものです。</p>
        </div>

        <p>モデリングという言葉は、データベースシステムで実践されるようになってから半世紀の間に、非常に異なる意味を持つようになりました。この冒頭の章では、モデリングを神秘的なものから解き明かし、その応用、方法論、利点を含めて、本書全体の目的を前置きします。この旅を通じて、モデリングの概念は、組織がデータを設計および管理し、さらに重要なことに、自分自身を理解するのに役立つ一連の方法と用語へと展開されます。</p>

        <p>最も広い解釈では、モデリングは、より複雑なものをナビゲートしたり設計したりするのに役立つ選択的な簡略化です。どのようなシステムも、より小さく、より管理しやすい部分に分解することができます。個々の部分を操作することは簡単かもしれませんが、全体的な戦略を考慮せずに行うことは、将来的にスケーラビリティとメンテナンスを妨げることが確実な、不安定な提案です。</p>

        <p>モデリングは一般的にデータベースに依存しないと考えられていますが、Snowflakeのような最新のクラウドデータプラットフォームは、その革新的なアーキテクチャと消費ベースの価格設定により、ユーザーに多くの独自の機能を提供します。それをサポートするプラットフォームのネイティブ機能を活用する、明確で前向きな設計が、ビジネスニーズを満たし、予測することができるコスト効率の高いソリューションを構築する鍵となります。</p>

        <p>データ駆動型組織の分析要件は、悪名高いほど複雑で常に進化しているため、モデリングはペースを保ち、アイデアから実行までデータチームに同行しなければなりません。これを達成するために、モデリングはデータベーステーブルの構造と関係を超えて、基礎となるデータを移動し形成する変換ロジックを受け入れる必要があります。Snowflakeの機能とアーキテクチャの詳細に傾倒することによってのみ、モデルを最初から最後まで効率的に構築することができます。</p>

        <h2>この章では、以下の主なトピックを扱います：</h2>

        <ul>
            <li>日常生活におけるモデルの有用性を認識する</li>
            <li>実際のモデリング規約を垣間見る</li>
            <li>モデリングツールキットのツールに慣れる</li>
            <li>企業チームにとってのモデリングの利点を明らかにする</li>
            <li>戦略的計画にモデリングを組み込む</li>
            <li>トランザクションシステムと分析システムのモデリングアプリケーションを理解する</li>
        </ul>

        <h2>技術要件</h2>

        <p>本書は、Snowflake Data Cloud専用のデータモデリングに焦点を当てています。モデリングには多くのシステムに依存しない用語と規約が含まれていますが、本書では、物理モデルと構造化クエリ言語（SQL）変換を構築する際に、Snowflakeアーキテクチャ、データ型、および関数の独自の機能を活用します。</p>

        <p>以下の章の演習に従うには、スキーマ、オブジェクトの作成、およびデータのロードのためのサンドボックス領域へのアクセスを持つSnowflakeアカウントが必要です。</p>

        <p>まだアクセス権がない場合は、Snowflakeの30日間無料トライアル（https://signup.snowflake.com/）にサインアップできます。</p>

        <p>本書では、モデリングプロセスの一部として視覚的なモデリング図を頻繁に使用します。図は手書きで描いたり、PowerPointやLucidchartで構築したりできますが、一般的なデータベースモデリング機能をサポートするツールをお勧めします。本書の演習では、概念的なデータベースに依存しない図から、デプロイ可能で実行可能なSnowflakeコードまで読者を導きます。このため、さまざまなモデリングタイプをサポートし、Snowflake構文を前方エンジニアリングできるツールをお勧めします。</p>

        <p>本書の図は、前述の機能をサポートし、2週間の無料トライアルを提供するSqlDBMオンラインデータベースモデリングツール（https://sqldbm.com/Home/）を使用して生成されました。</p>

        <h2>目的を持ったモデリング</h2>

        <p>モデルは複雑なシステムを簡素化するために使用されます。現代の都市を例にとると、高速道路、電力網、交通システムなど、複雑にリンクされたシステムで構成されていることがわかります。これらのシステムは同じ物理的な領域で動作していますが、それらを理解するためには非常に異なるモデルが必要です。例えば、地下鉄システムは都市の多様な地形の下を蛇行し、曲がりくねっていますが、私たちのモデル（地下鉄マップ）は直線を使用し、駅をほぼ等間隔に配置しています。地下鉄マップは都市ではありません—それは、乗客が自分の旅を視覚化しやすくする都市の選択的な簡略化です。交通マップは非常にユビキタスなモデルであり、他の方法で行うことは想像しにくいですが、進化するのに時間がかかりました。</p>

        <p>今日私たちが知っている地下鉄マップは、1931年にハリー・ベックがロンドン地下鉄で使用されていた地図を再設計する際に発明されました。古いデザインは、間違った目標—地理的な正確さ—に焦点を当てていたため、ライダーにとって混乱を招くものでした。ベック以前の地図は次のようなものでした：</p>

        <figure>
            <img src="../images/chapter1/B19467_01_002.jpg" alt="図1.1 – ベック以前のロンドン地下鉄マップ" style="max-width: 100%; height: auto;">
            <figcaption>図1.1 – ベック以前のロンドン地下鉄マップ（レガシー地下鉄マップ）</figcaption>
        </figure>

        <p>幸いなことに、ベックは地図製作者ではなくエンジニアでした。地形の詳細を犠牲にすることで、ベックのデザインは乗客が旅に必要な停車駅の数を素早く数えることを可能にし、全体的な方向感覚を保持しました。この物語は、「地図は領土ではない」という格言を（文字通り）思い出させてくれます。</p>

        <p>地図と同様に、組織内のチームが運用環境を構成する多くの層を理解するのに役立つ、さまざまな種類のモデリングが存在します。また、地図と同様に、モデルは組織が今後の旅に備えるのに役立ちます。しかし、データベースをナビゲートするため、ましてやその将来を計画するために、どのようにモデルを使用するのでしょうか？</p>

        <h2>モデリングツールキットの活用</h2>

        <p>続ける前に、モデリングのサービスでよく一緒に使用される3つの異なる概念を正式に描写する必要があります。これにより、後のセクションでモデリングツールキットの特定のツールを参照することが簡単になります。各部分がデータベースの設計と管理のより広い領域のどこに適合するかを理解することで、本書の後半でより深い技術的概念に飛び込むことがより意味のあるものになり、消化しやすくなります。</p>

        <p>3つのコンポーネントは次のとおりです：</p>

        <ul>
            <li>自然言語セマンティクス—言葉</li>
            <li>技術的セマンティクス—SQL</li>
            <li>視覚的セマンティクス—図</li>
        </ul>

        <p>これらのそれぞれについて、次のように詳しく説明しましょう：</p>

        <h3>自然言語セマンティクス</h3>

        <p>モデルの詳細をコミュニケートする際に使用される用語。これらは、より複雑な概念をよりシンプルな用語でカプセル化するために、事前に定義された規約を使用する合意された言葉です。例えば、言葉のやり取りに関与する両当事者がサロゲートキーの概念を理解している場合、それが整数シーケンスやハッシュ値などの本質的なビジネス上の意味を持たないテーブルレコードの一意の識別子であることを説明する必要がなくなります。</p>

        <p>効果的な技術的会話を確実にするために、モデリングのセマンティクスに精通していることが役立ちます。複雑な概念を簡潔に伝えることで時間を節約するだけでなく、誤って伝えないことでさらに多くの時間を節約します。ロンドンでチップスを注文する場合とロサンゼルスで注文する場合では、ウェイターは異なる食べ物を返すでしょう。適切にモデル化されたデータベースは、同じサロゲートキーに対して異なるレコードを返すことは決してありません。</p>

        <h3>技術的セマンティクス</h3>

        <p>SQLは、リレーショナルデータベース管理システム（RDBMS）でデータを管理するために使用されるドメイン固有言語です。汎用言語（例：YAMLやPython）とは異なり、ドメイン固有言語はアプリケーションがはるかに小さいですが、はるかに豊かなニュアンスと精度を提供します。ウェブサイトをフォーマットしたり、電子メールを送信したりすることはできませんが、SQLを使用すると、データベースの構造を作成し、その内容を操作できます。</p>

        <p>SQLは、モデリングの概念（言葉や画像で表現される）とデータベースで物理的に定義されているものとの橋渡しをします。Snowflakeは、米国規格協会（ANSI）準拠のSQL構文を使用します。つまり、その基本的なコマンド（SELECT、UPDATE、DELETE、INSERT、WHEREなど）は、この標準を使用する他のデータベースベンダーと互換性があります。Snowflakeはまた、ANSI標準SQLを超えた多くの追加機能、句、および規約を提供し、ユーザーにデータベースを管理する柔軟性を追加します。</p>

        <p>残念ながら、そのドメイン固有の性質により、SQLには重大な制限があります。データベースが明示的に理解するものしか表現できません。SQLはテーブル構造を定義し、データを正確に操作できますが、基礎となるビジネス要件を簡単に明確にするには詳細すぎます。</p>

        <h3>視覚的セマンティクス</h3>

        <p>そのシンプルさを通じて、画像は他の形式の言語では単純にできない情報の密度を伝えることができます。モデリングでは、図はSQLのドメイン固有の精度と自然言語のニュアンスを組み合わせます。これにより、図はデータモデルのビジネス上の意味と技術的な詳細をキャプチャするために多くのことを処理できます。</p>

        <p>まず、図は提示する詳細のレベルが異なります—観察者が探しているものを正確に提供し、情報で圧倒（または圧倒しない）しません。最も重要なことに、図で使用されるセマンティック規約は普遍的であり、データアナリストやエンジニア以外の人々にも理解できます。はい—モデリング図は技術図面と見なされます。合意された視覚的規約を通じて厳密な技術的概念を表します。しかし、最も単純な形式では、モデルは事前の知識なしにほとんど直感的に理解できます。論理的および物理的などのより高度なレベルでさえ、モデルを読むことを学ぶことは、SQLを学ぶよりもはるかに簡単です。</p>

        <p>これらのセマンティクスがすべて一緒になり、組織全体で理解されると、エリック・エヴァンスがドメイン駆動設計で最初に説明したユビキタス言語を形成します。モデリングは、ビジネスを説明し、それをサポートするデータ資産を保存するために組織全体で普遍的に理解される語彙の一部を形成します。しかし、それはモデリングが提供する多くの利点の1つにすぎません。</p>

        <h2>データベースモデリングの利点</h2>

        <p>戦略なき戦術は敗北前の騒音である。（孫子）</p>

        <p>多くの人にとって、データベースモデリングは古い図、難解な記号、またはプロジェクトの最後の余分な作業を思い起こさせます。わずか10年前、2000年代初頭の分散コンピューティングの台頭に後押しされて—ビッグデータの概念を普及させた—モデリングは死んだという概念が悪名を得ました。より正確には、安価でほぼ無限のコンピューティングパワーが計画と設計を過去のものにしたと考えられていました。柔軟な半構造化データ形式とそれらをその場で解析する能力—スキーマオンリードとして知られている—がモデリングを時代遅れにしたと言われていました。</p>

        <p>最終的に、運用とメンテナンスのコストが現実に追いつき、スキーマオンリードアプローチの2つの大きな欠点を明らかにしました。1つは、データがどのように構造化されていても、それがサポートするビジネスに機能的に結び付けられている必要があるということです。言い換えれば、半構造化形式は万能薬でもなければ、ビジネス検証のプロセスを放棄する言い訳でもありません。2つ目—そして最も重要なこと—は、モデルは単にデータベースにアップロードされた後にデータが取る形状ではなく、むしろビジネス運営の青写真であり、それなしには持続可能なアーキテクチャを構築することは不可能です。</p>

        <p>持続可能なソリューションには、設計が基礎となるビジネスモデルと一致することを保証するための長期戦略が必要です。これがなければ、スキーマオンリード（第15章「半構造化データのモデリング」で説明）、スタースキーマ（第17章「モダンテクニックによるデータモデルのスケーリング」で説明）、またはその他のスキーマは、どこにもつながらない近視眼的な戦術です。しかし、正しく行われると、モデリングはデータベースアーキテクチャの開発をより機敏にし、プロジェクトがアイデアフェーズから実装まで進化するのに役立ちます。開発のすべての段階で、モデルは設計を次のフェーズに推進し、追加のビジネスコンテキストを提供するために必要な会話をサポートするガイドとして機能します。実装されると、モデルは、作成を支援したシステムをユーザーが理解し、ナビゲートし、進化させるのに役立つ生きたドキュメントになります。</p>

        <p>すべての組織は技術的な意味でモデリングを行います—テーブルを作成し、データを変換します—しかし、誰もが戦略的に、エンドツーエンドで、言葉の広い意味でモデリングするわけではありません—それによって長期的な利点を放棄します。これらの利点のいくつかは次のとおりです：</p>

        <ul>
            <li>より広いビジネスモデルのコンセンサスと可視性</li>
            <li>ビジネスチームとのより生産的な会話</li>
            <li>要件の品質の向上</li>
            <li>技術的な会話でのより高い信号、より低いノイズ</li>
            <li>クロスプラットフォーム、クロスドメイン、および広く理解されている規約</li>
            <li>ビジネスとそのデータベースフットプリントの全体像の視覚的概要</li>
            <li>予備設計が実装の青写真になる</li>
            <li>新しいチームメンバーのオンボーディングの加速</li>
            <li>データをよりアクセスしやすくし、組織内でセルフサービスを解き放つ</li>
            <li>データベースランドスケープを大規模に管理可能に保つ</li>
            <li>複雑なデータパイプラインを把握する</li>
        </ul>

        <p>正式なモデリングなしで作業することの困難さを示すために、Snowflakeの共有TPC-Hデータセット（SNOWFLAKE_SAMPLE_DATAという共有データベースで利用可能）に基づく単純なスキーマを取り上げることができます。これは、最初に見ると次のようになります：</p>

        <figure>
            <img src="../images/chapter1/B19467_01_003.jpg" alt="図1.2 – Snowsight UIのテーブルのリスト" style="max-width: 100%; height: auto;">
            <figcaption>図1.2 – Snowsight UIのテーブルのリスト</figcaption>
        </figure>

        <p>これらのテーブルは、言葉の厳密な意味でモデル化されており、データも含まれていますが、そのデータが何を表しているか、他のテーブルのデータとどのように関連しているか、またはビジネス運営の広いコンテキストのどこに適合するかについては、ほとんど情報が得られません。</p>

        <p>直感は、SALES_ORDERとCUSTOMERが関係を共有していることを示唆していますが、この主張はテストする必要があります。わずか8つのテーブルのこの些細な例でさえ、データを完全にふるいにかけてそのコンテキストを理解するにはかなりの時間がかかります。</p>

        <p>皮肉なことに、私たちが探している詳細の多くは、過去のある時点でモデル化されており、すでに物理テーブルの設計に組み込まれています。私たちはそれらを見ることができません。地図がなければ、地形は見えません。</p>

        <p>エンティティ関係図（ERD）と呼ばれるモデリング規約を通じて視覚化された同じテーブルのセットは次のとおりです：</p>

        <figure>
            <img src="../images/chapter1/B19467_01_005.jpg" alt="図1.3 – カラスの足記法を使用した概念モデル" style="max-width: 100%; height: auto;">
            <figcaption>図1.3 – カラスの足記法を使用した概念モデル</figcaption>
        </figure>

        <p>一目で、全体像が焦点を合わせます。このような図は、データの背後にあるビジネス概念を理解し、それらが整合していることを確認できます。視覚的なモデルを持つことで、個々のテーブルからズームアウトし、ビジネスのセマンティクスを理解することもできます：関与する個々の部分は何で、どのように相互作用しますか？このグローバルな視点により、組織内のすべての人が技術的な背景を必要とせずにデータ資産を見つけて理解する手段を得ることができます—したがって、ビジネスアナリストや新入社員は、データチームの助けなしに情報の価値を解き放つことができます。</p>

        <p>組織が成長し、人員とデータ資産が拡大するにつれて、必然的に大きくなりすぎて、どの人、またはチームでさえ調整できなくなります。ここで、データモデリングを採用した組織は、そうでない組織から際立っています。モデリングは、組織がデータランドスケープをスケールするのに役立つものであるか、それらを妨げる技術的負債である可能性があります。</p>

        <p>しかし、そのすべての利点にもかかわらず、モデリングは成功を保証するクッキーカッターソリューションではありません。モデリングには多くのアプローチがあり、さまざまなワークロードに適したさまざまなモデリング方法論があります。本書全体を通じて、これらの違いを理解し、ファーストプリンシプルアプローチを使用して最適なソリューションを適用できるようにするモデリングの基礎に取り組みます。まず、2つの主要なデータベースのユースケースを分解し、それぞれでモデリングが果たす役割を観察することから始めます。</p>

        <h2>運用および分析モデリングシナリオ</h2>

        <p>今日私たちが知っているリレーショナルデータベースは、1970年代に登場しました—組織が個々のテープではなく集中リポジトリにデータを保存できるようにしました。その10年後、オンライントランザクション処理（OLTP）が登場し、データへのより高速なアクセスを可能にし、予約や銀行窓口システムなどのデータベースの新しい用途を解き放ちました。これはデータベースのパラダイムシフトであり、データアーカイブから運用システムへと進化しました。</p>

        <p>限られたリソースのため、運用プロセスを実行していたのと同じデータベースでデータ分析を実行することはできませんでした。運用データを分析する必要性は、1980年代に、後に意思決定支援システム（DSS）として知られるようになった管理情報システム（MIS）を生み出しました。データは運用データベースからDSSに抽出され、そこでビジネスニーズに応じて分析できます。OLTPアーキテクチャは後者のケースに最適ではないため、オンライン分析処理（OLAP）が登場し、ユーザーが複雑なクエリを使用して複数の視点から多次元データを分析できるようになりました。これは、Snowflakeなどの最新のデータプラットフォームで今日使用されているのと同じパラダイムです。</p>

        <p>OLAPシステムでのデータの保存と管理へのアプローチは、運用またはトランザクションデータベースとは根本的に異なります。OLAPシステムのデータは、一般的にデータウェアハウス（DW、DWHとも呼ばれる）に保存されます—分析と意思決定を目的として、さまざまなソースから構造化データを保存する集中リポジトリです。トランザクションシステムは最新バージョンの真実を保持し、一般的に個々のレコードに関心がありますが、データウェアハウスは多くの履歴バージョンをスナップショットし、さまざまな分析ニーズを満たすために大量のデータを集約します。</p>

        <p>データは、日々のビジネス運営（例：予約、販売、引き出し）が記録されるときにトランザクションデータベースで発生します。対照的に、ウェアハウスは作成するのではなく、1つまたはさまざまなソースシステムから抽出された情報をロードします。トランザクションデータベースとウェアハウスの機能的な違いは、異なるモデリングの課題を提示します。</p>

        <p>トランザクションシステムは、処理することが期待されるデータの性質に合わせてモデル化する必要があります。これは、トランザクションに必要な形式、関係、および属性を知ることを意味します。</p>

        <p>トランザクションデータベースモデルの主な関心事は、そのテーブル間の構造と関係です。</p>

        <p>対照的に、データウェアハウスはソースシステムから既存のデータをロードします。データウェアハウスは、単一のトランザクションを定義することに関心があるのではなく、ビジネスの質問に答えるためにさまざまなディメンション全体で多数のトランザクションを分析することに関心があります。これを行うために、データウェアハウスはソースデータを変換して複数のビジネス分析を満たす必要があり、これは多くの場合、さまざまな粒度と詳細を持つコピーを作成することを意味します。</p>

        <p>データウェアハウスでのモデリングは、共通要素を適合させ、ロジックを使用してデータを変換することにより、ソースシステムのリレーショナルモデルに基づいて構築されます。</p>

        <p>ちょっと待って—変換ロジックがデータウェアハウスモデリングの中核概念である場合、なぜモデリングの議論から一貫して欠けているのですか？変換モデリングを正当に扱うには、一般的なモデリング原則の普遍性を放棄し、プラットフォーム固有の領域（つまり、構文、ストレージ、およびメモリ使用率）に踏み込む必要があるためです。対照的に、本書はSnowflakeの詳細を受け入れ、物理テーブルの背後にある変換ロジックに飛び込むことで物理モデリングを超えます。このアプローチは、基礎となるモデリングの概念をより完全に理解し、モデルを構築するだけでなく、最も効率的な方法でそれらをロードして自動化するために必要なSQLレシピを読者に提供します。後の章で見るように、これはSnowflakeが本当に輝き、パフォーマンスとコスト削減の利点をもたらす場所です。</p>

        <div class="notice">
            <div class="notice-title">💡 SnowflakeはOLAPに限定されていますか？</div>
            <p>Snowflakeの主なユースケースは、データウェアハウスのそれです—大規模なデータセットにわたる多次元分析を大規模に可能にするすべてのOLAPプロパティを備えています。しかし、2022年のSnowflake Summitで、同社はHybrid Unistoreと呼ばれる新しいテーブルタイプを発表しました。これは、1つのセマンティックオブジェクトの下にOLTPストレージテーブルとOLAP分析テーブルの両方を備えています。この発表は、SnowflakeユーザーがSnowflakeが知られている分析パフォーマンスを活用しながら、トランザクションOLTPデータベーススキーマを設計できるようになったことを意味します。Hybrid Unistoreテーブルについては、後の章で詳しく説明します。</p>
        </div>

        <p>OLAPおよびOLTPシステムは、さまざまな種類のデータベース操作に最適化されていますが、それらは依然として心臓部のデータベースであり、SQLを使用して同じオブジェクトのセット（テーブル、制約、ビューなど）で動作します。ただし、各ユースケースでは、内のデータをモデル化するための非常に異なるアプローチが必要です。次のセクションでは、各シナリオでモデリングが通常どのように見えるかを示します。</p>

        <h2>リレーショナルおよび変換モデリングの見方</h2>

        <p>前のセクションでは、運用シナリオとデータウェアハウスシナリオの間でモデリングがどのように異なるかを説明しています。モデリングプロセスを詳細に探求する前に、リレーショナルおよび変換モデリングのルックアンドフィールと、私たちが目指しているものを理解することが役立ちます。続行する前に、トランザクションデータベースとデータウェアハウスの主な違いを要約すると役立ちます。以下の表でこれらが何であるかを確認できます：</p>

        <figure>
            <table style="width: 100%; border-collapse: collapse; margin: 1.5rem 0;">
                <caption>図1.4 – トランザクションデータベースとウェアハウスの一般的な違い</caption>
                <thead>
                    <tr style="background-color: #f1f5f9;">
                        <th style="border: 1px solid #e2e8f0; padding: 0.75rem; text-align: left;">トランザクションデータベース</th>
                        <th style="border: 1px solid #e2e8f0; padding: 0.75rem; text-align: left;">データウェアハウス</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">日常業務をサポート</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">運用上の洞察を提供</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">単一レコードで動作</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">多くのレコードを要約</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">現在の瞬間の時点で正確</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">時間の経過に伴う履歴スナップショット</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">単一の真実の源（SSOT）、非冗長</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">さまざまな分析をサポートするために冗長</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">ビジネス運営によって定義されるデータモデル</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">ビジネスの質問によって生成されるデータモデル</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">静的で構造化されたデータモデル</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">継承された構造と動的に変換されたデータモデル</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">単一アプリケーションデータ</td>
                        <td style="border: 1px solid #e2e8f0; padding: 0.75rem;">複数のソースからの収束データ</td>
                    </tr>
                </tbody>
            </table>
        </figure>

        <p>これらの違いを考慮して、次のセクションでは、各システムでモデリングがどのように見え、何を達成しようとしているかを示します。</p>

        <h3>運用システムでのモデリングの見た目</h3>

        <p>ここに至るまでのモデリングワークフローを完全に無視して（これは後の章でカバーされます）、トランザクションシステムで最も一般的に見られるタイプのモデリングの例を観察できます。図1.5の物理図は、必要なテーブルを宣言するための青写真と、それらのビジネスコンテキストを理解するためのガイドの両方として機能します。</p>

        <p>モデリング規約に従って（まだ馴染みがなくても心配しないでください—今後の章で徹底的にカバーされます）、この単純な図から多くの情報を推測できます。例えば、人は8桁の識別子（主キー）によって一意に識別され、社会保障番号（SSN）、運転免許証、名前、生年月日を持っている必要があります。</p>

        <p>2つのテーブル間の1対多の関係は、人が必ずしもアカウントを作成する必要はないが、アカウントは1人の人に属している必要があることを確立します：</p>

        <figure>
            <img src="../images/chapter1/B19467_01_006.jpg" alt="図1.5 – カラスの足記法を使用した物理モデル" style="max-width: 100%; height: auto;">
            <figcaption>図1.5 – カラスの足記法を使用した物理モデル</figcaption>
        </figure>

        <p>これらの詳細は、属性、データ型、および制約のリストと組み合わせて、これらのテーブルに書き込むことができるデータの種類を決定するだけでなく、ビジネスの運営方法のアイデアも提供します。では、これは分析データベースでどのように異なるのでしょうか？</p>

        <h3>分析システムでのモデリングの見た目</h3>

        <p>データウェアハウスのシナリオでは、PERSONテーブルとACCOUNTテーブルは最初から定義されません—それらが存在するソースから抽出され、ロードされます—構造とデータの両方をプロセスに持ち込みます。次に、組織のビジネスの質問に答えて、分析変換が始まります。これは、抽出変換ロード（ETL）として知られるプロセスです。（ELTが優先処理順序になりましたが、元の用語は定着しました。）</p>

        <p>管理チームが、どの年齢層（10年ごと）がどのアカウントタイプを開設しているかを分析し、独立した分析のために結果を別のテーブルに保存したいとします。</p>

        <p>次の図は、変換分析を通じて取得されたオブジェクトの結果のリレーショナルモデルを示していますが、ビジネスコンテキストは提供しません：</p>

        <figure>
            <img src="../images/chapter1/B19467_01_007.jpg" alt="図1.6 – 変換要件のリレーショナルモデル" style="max-width: 100%; height: auto;">
            <figcaption>図1.6 – 変換要件のリレーショナルモデル</figcaption>
        </figure>

        <p>物理モデリングはそのようなテーブルを記述できますが（図1.6に見られるように）—アカウントタイプと年齢とアカウント数を整数として含む—そのようなモデルは、ここに示す最も関連性の高い詳細を伝えることができません：</p>

        <ul>
            <li>分析を実行するために使用されるロジック</li>
            <li>ソーステーブルと出力の関係</li>
        </ul>

        <p>この例のACCOUNT_TYPE_AGE_ANALYSISのビジネス要件は、ターゲットテーブルからソースキーフィールドを意図的に除外し、リレーショナルリンクを確立する可能性を防ぎます。ただし、リレーショナルモデルは依然として重要な役割を果たします。ソースがどのように関連しているか、および必要な分析を生成するためにそれらを正しく結合する方法を教えてくれます。</p>

        <p>ロジックは、ここに示すようにPERSONとACCOUNTを結合することで構築できます：</p>

        <pre><code>CREATE TABLE account_types_age_analysis AS
SELECT
    a.account_type,
    ROUND(DATEDIFF(years, p.birth_date, CURRENT_DATE()), -1
    ) AS age_decade,
    COUNT(a.account_id) AS total_accounts
    FROM account AS  a
     INNER JOIN person AS p
     ON a.person_id = p.person_id
GROUP BY     1, 2;</code></pre>

        <p>ACCOUNT_TYPE_AGE_ANALYSISとそのソースの間にリレーショナル接続はありませんが、それらとその列には明確な依存関係があります。エンティティと関係を伝えるERDを使用する代わりに、変換パイプラインは系統図を通じて視覚化されます。このタイプの図は、ここに示すように、すべての中間ステップを含む、ソースからターゲットへの列レベルのマッピングを提供します：</p>

        <div class="notice">
            <div class="notice-title">🖼️ 画像なし</div>
            <p>図1.7 – 視覚的に見る変換モデリング</p>
            <p><em>この図の画像ファイルは提供されていません。系統図は、ソーステーブル（PERSON、ACCOUNT）から中間変換を経て、最終的なACCOUNT_TYPE_AGE_ANALYSISテーブルへのデータフローを示すものです。</em></p>
        </div>

        <p>それを構築するために使用されるSQLロジックと組み合わせて、系統グラフは、分析/ウェアハウジングシナリオでのソースとターゲット間の変換関係の完全な画像を提供します。</p>

        <p>リレーショナルアプローチと分析アプローチの両方をモデリングに目撃したので、両方がエンタープライズ規模のSnowflake環境で遭遇する可能性のある複雑な動的環境をナビゲートする上で重要な役割を果たすことは明らかです。</p>

        <p>モデリングが何を伴うか、およびこの目的に活用できるSnowflakeプラットフォームの独自の機能の表面をざっと見ただけですが、この章では、データベースシステムの構築、維持、および文書化においてモデリングが果たす重要な役割についてのアイデアを提供してくれたことを願っています。今後の章でモデリングの言語的、技術的、視覚的モデリングセマンティクスの詳細に飛び込む前に、学んだことを確認しましょう。</p>

        <h2>まとめ</h2>

        <p>モデリングから逃れることはできません。私たちは日常生活でそれを使用して、私たちの周りの世界の複雑さを計画し、ナビゲートします—データベースも例外ではありません。一部の読者にとって、この章で提示されたモデリングスタイルは、データベースランドスケープを概念化する新しい方法かもしれませんが、他の読者はその記法とユースケースに再び慣れ親しんでいるかもしれません。会社のビジネスモデルについて考えているか、チームメンバーと最終的な設計を共有しているかにかかわらず、私たちは皆、さまざまな程度でモデリングに従事しています。</p>

        <p>データベースモデリングを受け入れ、一般的に理解されている言語で話すことを学ぶことは、組織全体に多くの時間節約と協力的な利点を解き放ちます。戦術的に反応するのではなく、長期的に考え、戦略的にモデリングすることで、データベース設計をそれらが支えるビジネスに合わせ、それらの実行可能性を確保します。モデリングが明らかにする利点とそれを実装できる場所を見てきたので、そのコンポーネントを分析して、それらがどこで使用されるべきか、およびそれらがどのように自然な設計の進行を形成するかを正確に理解し始めることができます。</p>

        <p>次の章では、データベース設計で使用される4つのモデリングタイプを探求し、それらがどこで優れているか、およびアイデアを取り、最終製品をナビゲートして維持するための生きたプロジェクトアーティファクトを生成しながら、技術的なシステム設計に進化させるのにどのように互いに構築されるかについて説明します。</p>

        <h2>さらなる読書</h2>

        <p>この章で前述したエリック・エヴァンスの本は、表面を超えてシステム自体の意図に到達することにより、効果的なモデルを作成する方法を探求しています。特定の技術分野、方法、または規約に制限されずに、モデルを通じた効果的なコミュニケーションの領域により深く入りたい人にとって推奨される読み物です：</p>

        <p>Evans, Eric. Domain-Driven Design: Tackling Complexity in the Heart of Software. Addison-Wesley Professional, 2004.</p>

        <h2>参考文献</h2>

        <p>Legacy Tube map Wikimedia Commons, https://commons.wikimedia.org/wiki/File:Tube_map_1908-2.jpg. Accessed October 2, 2022.</p>
"""
    return content

def create_html_file(filename, content, title):
    """HTMLファイルを作成"""
    template = f"""<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noodp, noimageindex">
    <meta name="googlebot" content="noindex, nofollow">
    <title>{title} - SnowflakeによるデータモデリングLab</title>
    <link rel="stylesheet" href="{"../css/style.css" if "chapter" in filename or "part1/" in filename else "css/style.css"}">
</head>
<body>
    <nav>
        <ul>
            <li><a href="{"../index.html" if "chapter" in filename or "part1/" in filename else "index.html"}">ホーム</a></li>
            <li><a href="{"../preface.html" if "chapter" in filename or "part1/" in filename else "preface.html"}">はじめに</a></li>
            <li><a href="{"index.html" if "part1/" in filename and "index" not in filename else "../part1/index.html" if "chapter" in filename else "part1/index.html"}">第1部</a></li>
        </ul>
    </nav>

    <div class="container">
{content}
        
        <footer>
            <p>個人学習用コンテンツ | 最終更新: {datetime.now().strftime('%Y年%m月%d日')}</p>
        </footer>
    </div>
</body>
</html>"""
    
    # ファイルパスの作成と書き込み
    full_path = os.path.join("/Users/kake/work/modelingbook/docs", filename)
    os.makedirs(os.path.dirname(full_path), exist_ok=True)
    
    with open(full_path, 'w', encoding='utf-8') as f:
        f.write(template)
    
    print(f"生成完了: {full_path}")

def main():
    """メイン処理"""
    # Chapter 1の画像付き版を生成
    create_html_file("part1/chapter1.html", translate_chapter1_with_images(), "第1章：モデリングの力を解き放つ")
    
    print("\nChapter 1の全文翻訳（画像付き）が完了しました！")

if __name__ == "__main__":
    main()