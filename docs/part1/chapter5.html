<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noodp, noimageindex">
    <meta name="googlebot" content="noindex, nofollow">
    <title>第5章：Snowflakeオブジェクトを通じたモデリング - SnowflakeによるデータモデリングLab</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <nav>
        <ul>
            <li><a href="../index.html">ホーム</a></li>
            <li><a href="../preface.html">はじめに</a></li>
            <li><a href="index.html">第1部</a></li>
        </ul>
    </nav>

    <div class="container">

        <h1>第5章：Snowflakeオブジェクトを通じたモデリングの実践</h1>
        
        <div class="notice">
            <div class="notice-title">📖 この章について</div>
            <p>この内容は「Data Modeling with Snowflake」の第5章を、省略することなく完全に日本語に翻訳したものです。</p>
        </div>

        <p>最も純粋な形では、リレーショナルモデリング（厳密に強制される物理制約を持つ正規化されたテーブル）は、オンライントランザクション処理（OLTP）データベースで最も頻繁に見られます。トランザクションデータベースは、時間の経過に伴う情報の変更を追跡し、時間的な次元にわたる追加の（時点での）分析を可能にする履歴スナップショットを保存するデータウェアハウスとは異なり、ビジネス情報の最新（現状）バージョンを保存します。</p>

        <p>しかし、これはリレーショナルモデリングの概念がオンライン分析処理（OLAP）データベースに適用されないことを意味するものではありません。まったく逆です。データウェアハウスは、トランザクションシステムから既存のエンティティと関係を複製するだけでなく、他のソースからのディメンションを適合させ、ダウンストリームの変換と分析でそれらを結合するという追加のタスクを管理する必要があります。</p>

        <p>モデリングの共通言語をマスターするもう1つの理由は、前の章で説明したハイブリッドUnistoreテーブルです。これは、トランザクションシステムとウェアハウスの境界線を曖昧にし、他のアーキテクチャでは決して可能ではなかったユースケース（運用システムとウェアハウスの両方として機能する同じプラットフォームからのトランザクションデータへのリアルタイム、ELT不要の分析アクセスなど）を解き放つ準備ができています。</p>

        <h2>この章では、以下の主なトピックを扱います：</h2>

        <ul>
            <li>エンティティがテーブルとしてどのように表現され、Snowflakeが基礎となるストレージをどのように管理するかを理解することで、効率的な設計を確保する</li>
            <li>属性の適切なデータ型設定の利点を探る</li>
            <li>データベース制約を理解し、Snowflakeでそれらを管理する</li>
            <li>識別子と主キーの利点を活用する方法を学ぶ</li>
            <li>複数の主キー候補が存在する場合の代替キーの使用</li>
            <li>外部キー関係を通じてモデルを結び付ける</li>
            <li>必須列の指定とチェック</li>
        </ul>

        <p>前の章でカバーした基本的なモデリング概念を再訪し、それらを対応するSnowflakeオブジェクトに結び付けることから始めましょう。</p>

        <h2>エンティティとしてのテーブル</h2>

        <p>データベースの詳細に入る前に、ビジネスレベルでのエンティティの概念を思い出しましょう：組織が情報を維持したいビジネスに関連する人、オブジェクト、場所、イベント、または概念。言い換えれば、エンティティは共通のプロパティを持つビジネス関連の概念です。エンティティを識別して名前を付けるための経験則は、それらが単数形の英語名詞（customer、item、reservationなど）に準拠することです。</p>

        <p>Snowflakeで情報を保存および維持するための明らかな候補はテーブルです。SQLを通じて、テーブルはユーザーにエンティティの詳細にアクセスして操作するための標準的で馴染みのある方法を提供します。前の章で見たように、Snowflakeテーブルにはいくつかのフレーバーがあり、さまざまなバックアップとリカバリのオプションを提供しています。適切なタイムトラベルとフェイルセーフを提供するテーブルタイプを選択することに加えて、Snowflakeテーブルは会社のほぼゼロメンテナンスの主張に応えています。手動で維持するインデックス、テーブルスペース、またはパーティションはありません。</p>

        <p>ユーザーが制御できるストレージの2つの側面は、Snowflakeがデータを内部列形式で保存するために使用するマイクロパーティションと、それらがどのようにクラスター化されるかだけです。2つの側面をより詳しく見てみましょう。</p>

        <h3>Snowflakeがデータを保存する方法</h3>

        <p>Snowflakeテーブルのデータは、マイクロパーティションと呼ばれる連続したストレージユニットを使用して列形式で保存されます。通常、データベースは大きなテーブルを物理パーティションに分割して、パフォーマンスとスケーラビリティを向上させます。ただし、物理パーティションにはメンテナンスが必要であり、データスキュー（一部のパーティションが他のパーティションよりも大きくなる）が発生します。</p>

        <p>Snowflakeは、マイクロパーティションを小さく保ち（非圧縮で約50〜500 MB）、サービスレイヤーを通じて透過的に管理することで、これらの制限を回避します。マイクロパーティションは不変であるため、データ操作言語（DML）操作はより効率的であり、常に新しいパーティションを作成します。そのサイズが小さいため、マイクロパーティション内の個々の列に対して詳細な統計を保持でき、それぞれがデータ型に基づいて最適に圧縮されます。従来のパーティショニングとは異なり、マイクロパーティションは値の範囲で重複することができます（ただし、単一のレコードが複数のパーティションにまたがることはありません）。</p>

        <p>マイクロパーティションは、データがテーブルにロードされるときの自然な順序によって作成されます。たとえば、新しいトランザクションがSALESテーブルに毎日ロードされる場合、transaction_dateがテーブルの自然なパーティションを形成します。一方、テーブルがクライアントでソートされた場合、クライアントによるパーティションが形成され、transaction_date値が重複します。</p>

        <p>マイクロパーティションの主な利点は、そのメタデータ（値の範囲、個別のカウントなど）により、Snowflakeオプティマイザーがユーザークエリをプルーニングできることです。プルーニングは、フィルター値が存在しないことがわかっているマイクロパーティションの検索を回避します。たとえば、前の例のSALESテーブルが数百万のレコードに成長し、数千のマイクロパーティションにまたがっても、不要なパーティションをプルーニングし、値の範囲がクエリフィルター条件に一致するパーティションのみをスキャンすることで、クエリ結果をミリ秒単位で返すことができます。</p>

        <p>簡略化された概念的な例を使用して、マイクロパーティションの動作を見てみましょう。次のテーブルには、スーパーヒーローとその作成者に関するデータが含まれています。これは、ユーザーに表示される方法です：</p>

        <figure>
            <img src="../images/chapter5/B19467_05_001.jpg" alt="図5.1 – Snowflakeテーブルデータの論理ビュー" style="max-width: 100%; height: auto;">
            <figcaption>図5.1 – Snowflakeテーブルデータの論理ビュー</figcaption>
        </figure>

        <p>内部的には、2つのマイクロパーティションが作成され、データは列形式を使用して圧縮されます。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_002.jpg" alt="図5.2 – 2つのマイクロパーティションに分割されたSnowflakeテーブル" style="max-width: 100%; height: auto;">
            <figcaption>図5.2 – 2つのマイクロパーティションに分割されたSnowflakeテーブル</figcaption>
        </figure>

        <p>テーブルはDate Debutedで順序付けられているため、サービスレイヤーがテーブルをマイクロパーティションに分割すると、この列には値の自然なクラスタリングがあります。この例では2つのみを使用していますが、Snowflakeテーブルは、サイズに応じて数百万のマイクロパーティションで構成できます。</p>

        <p>パーティションメタデータを使用して、図5.2に示されている一部のみ（列値の範囲）、Snowflakeのクエリオプティマイザーは、クエリフィルターに応じてパーティションをプルーニングまたは無視できます。</p>

        <p>次の例では、オプティマイザーは、その値の範囲（メタデータからわかる）がフィルター条件に対応していないため、パーティション1の読み取りを安全にスキップできます。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_003.jpg" alt="図5.3 – 成功したクエリプルーニング" style="max-width: 100%; height: auto;">
            <figcaption>図5.3 – 成功したクエリプルーニング</figcaption>
        </figure>

        <p>オプティマイザーが値の範囲に基づいてマイクロパーティションを削除できない場合、一致するレコードを見つけるために、すべてのパーティションとその内容を読み取る必要があります。</p>

        <p>次の例では、作成者Paul Gustavsonがパーティション2にのみ存在するにもかかわらず、両方のパーティションが値の範囲に基づいて検索条件に一致するため、クエリプルーニングを実行できません：</p>

        <figure>
            <img src="../images/chapter5/B19467_05_004.jpg" alt="図5.4 – 指定されたフィルターでクエリプルーニングを実行できない" style="max-width: 100%; height: auto;">
            <figcaption>図5.4 – 指定されたフィルターでクエリプルーニングを実行できない</figcaption>
        </figure>

        <p>Snowflakeがマイクロパーティションを管理する方法は、データがテーブルにロードされる順序によって異なります。データは、ORDER BY句を使用して挿入時に明示的に順序付けることも、自然なロードパターン（CREATED_DATEまたはLOAD_DATEなど）によって暗黙的に順序付けることもできます。パーティショニングが検索フィルターと一致する場合、プルーニングによってクエリパフォーマンスが向上します。たとえば、LOAD_DATEでデータがロードされ、LOAD_DATE = CURRENT_DATEでクエリされる数百万行のテーブルでは、パフォーマンスはCURRENT_DATEのデータのみを保持するテーブルと同じになります。ただし、このフィルターを割引するか、他の属性を検索すると、おそらくクエリプルーニングの恩恵を受けることはありません。</p>

        <p>前の例で示したように、マイクロパーティショニングは、さまざまな程度の重複する列値を持つ複数のデータセグメントを作成します。クラスタリングとして知られるこのデータセグメンテーションは、テーブル構造を整理し、クエリパフォーマンスを向上させるために戦略的に使用できます。それを私たちの利点に使用する方法を理解しましょう。</p>

        <h3>クラスタリング</h3>

        <p>テーブルデータがマイクロパーティションに分割されると、列値は自然にデータセグメントにグループ化されます。列値の分散の程度とマイクロパーティション間での重複は、クラスタリングとして知られています。パーティション間で遭遇する重複が少ないほど、オプティマイザーが提供できるクエリと列のプルーニングの程度が高くなります。</p>

        <p>マイクロパーティションの列メタデータに加えて、Snowflakeサービスレイヤーは次のようなクラスタリング統計も保存します：</p>

        <ul>
            <li>各テーブルのマイクロパーティションの総数</li>
            <li>互いに重複する値を含むマイクロパーティションの数（テーブル列の指定されたサブセット内）</li>
            <li>重複するマイクロパーティションの深さ</li>
        </ul>

        <p>次の（簡略化された）例は、3つのマイクロパーティションがクラスタリング範囲でどのように重複するかを示しています。実際のテーブルには、より多くのパーティションと列があり、完全な分離を達成することは、クエリパフォーマンスを向上させるために必要でも可能でもありません。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_005.jpg" alt="図5.5 – パーティションの重複とクラスタリングの深さ" style="max-width: 100%; height: auto;">
            <figcaption>図5.5 – パーティションの重複とクラスタリングの深さ</figcaption>
        </figure>

        <p>データがテーブルからロードおよびクエリされる方法を検討する場合、テーブルがかなりのサイズに達すると、クラスタリングの深さまたは重複の程度（プルーニングとパフォーマンスには少ない方が良い）を考慮する必要があります。1つまたは複数の次元でテーブルを順序付けると、プルーニングによってクエリパフォーマンスが向上する可能性がありますが、ソート操作のコストがそれらの利益を相殺する可能性があります。</p>

        <p>一般的に、数百万行のテーブルでも、行に適用されるソートや順序付けなしで適切なパフォーマンスを提供します。ただし、ロードパターンが検索パターンと一致しない場合（たとえば、データはTRANSACTION_DATEでロードされるが、CLIENTでクエリされる）、特定のテーブルサイズを超えるとクエリパフォーマンスが低下する可能性があります。</p>

        <p>ユーザーは、Snowflakeのビジュアルクエリプロファイラーを使用してクエリプルーニング情報を評価できます。マイクロパーティションの総数が画面に表示され、クエリ中にアクセスされたパーティションの数が表示されます。</p>

        <p>次のスクリーンショットは、スキャンされたパーティションの数が合計と等しいことを示しています。つまり、オプティマイザーはプルーニングを実行できませんでした。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_006.jpg" alt="図5.6 – クエリプランを使用したプルーニングの評価" style="max-width: 100%; height: auto;">
            <figcaption>図5.6 – クエリプランを使用したプルーニングの評価</figcaption>
        </figure>

        <p>前述のように、プルーニングの欠如だけでは、クエリパフォーマンスの低下の指標ではありません。クエリ期間は、キャッシング、クエリの複雑さ、データ量などの要因により主観的です。ただし、クエリパフォーマンスが期待を満たさない場合、図5.6に示すような他のクエリ操作に対する高いテーブルスキャン率やプルーニングの欠如などの要因は、テーブルを再クラスター化する必要があることを示している可能性があります。</p>

        <p>再クラスター化は、必要なソートを適用しながらテーブルを再作成することで手動で実行することも、Snowflakeによって自動的に処理することもできます。</p>

        <h3>自動クラスタリング</h3>

        <p>Snowflakeは、受信データの自然なロードパターンを通じてクラスタリングを自動的に処理します。ただし、大規模なテーブル（マルチテラバイト以上）では、DML操作により、目的の列のクラスタリング品質が低下し、クエリパフォーマンスに影響を与える可能性があります。</p>

        <p>大きなテーブルサイズのため、テーブルの手動再ソートはコストがかかるため、Snowflakeは、指定されたクラスタリングキーを通じてテーブルの自動再クラスター化のオプションを提供します。クラスタリングキーは、Snowflakeが特定のテーブルのデータを自動的にソートし、必要に応じて透過的に再ソートするために使用する1つ以上の列（または式）です。</p>

        <p>クラスタリングキーを定義する利点は次のとおりです：</p>

        <ul>
            <li>クエリフィルターに一致しないデータをスキップすることによるプルーニングによるクエリパフォーマンスの向上</li>
            <li>より良い列圧縮とストレージコストの削減</li>
            <li>Snowflakeによって実行されるメンテナンス不要の自動再クラスター化</li>
        </ul>

        <p>ただし、自動再クラスター化操作は、手動で実行されるものと同じ処理コストが発生することを覚えておいてください。したがって、パフォーマンスがコストよりも優先される場合、またはクラスタリングパフォーマンスがそれを維持するために必要なクレジットを相殺する場合にのみ、クラスタリングキーの設定を検討してください。次の考慮事項は、後者が発生する可能性が高い時期を判断するのに役立ちます：</p>

        <ul>
            <li>テーブルには複数のテラバイト（TB）のデータと多くのマイクロパーティションが含まれています。</li>
            <li>クエリはクラスタリングを活用できます。通常、これは次の1つまたは両方が真であることを意味します：
                <ul>
                    <li>クエリはテーブルの行の小さな割合のみを読み取る必要がある</li>
                    <li>クエリはデータをソートする（たとえば、ORDER BY句を使用）</li>
                </ul>
            </li>
            <li>高い割合のクエリが、同じ少数の列で選択またはソートすることにより、同じクラスタリングキーから恩恵を受けることができます。</li>
        </ul>

        <p>クラスタリングの深さに関する詳細情報は、Snowflakeドキュメント（https://docs.snowflake.com/en/user-guide/tables-clustering-micropartitions.html）にあります。</p>

        <p>エンティティはリレーショナルモデルの主要な要素です。このセクションでは、エンティティをSnowflakeの物理テーブルに変換する方法と、最適なパフォーマンスとストレージのために検討すべき設計上の考慮事項を見ました。次のセクションでは、プロパティを追加してエンティティを拡張します。</p>

        <h2>列としての属性</h2>

        <p>前のセクションから、エンティティは組織が情報を維持したいビジネス関連の概念であることを思い出してください。概念モデリング中にビジネスチームと定義された、またはETLプロセス中に既存のソースデータからロードされた属性は、エンティティを記述するプロパティであり、列として保存されることを思い出してください。属性は、記述的（NAME、ADDRESS、QUANTITYなど）またはメタデータ（ETL_SOURCE、LOAD_DATEなど）である可能性があります。</p>

        <p>属性の性質（数値、文字列、日付、その他）は、概念レベルでビジネス要件を理解し、物理レベルで適切なデータ型を選択するための重要な詳細です。Snowflakeは、他のデータベースで見つかる基本的なデータ型（VARCHAR、DATE、INTEGERなど）と、テーブルコンテンツのモデリングと操作に関するエキサイティングな可能性を提供する、あまり一般的でないもの（VARIANTやGEOGRAPHYなど）を提供します。</p>

        <p>エンティティ属性に適切に割り当てることができるように、Snowflakeデータ型とその独自のプロパティを理解しましょう。</p>

        <h3>Snowflakeデータ型</h3>

        <p>SnowflakeはANSI準拠のデータベースであり、文字列、日付、数値を保存するための一般的なSQLデータ型をサポートしています。さらに、Snowflakeは、半構造化データと地理空間データを保存するためのより高度な型を提供します。マイクロパーティションについて説明したとき、列圧縮（データ型に基づく）がパフォーマンスとコスト管理の重要な要素として言及されました。ただし、データ型を正しく使用すると、テーブルコンテンツをクエリする際の使いやすさの利点も得られます。</p>

        <p>続行する前に、すでに精通していない限り、ドキュメント（https://docs.snowflake.com/en/sql-reference/intro-summary-data-types.html）でSnowflakeデータ型のリストを確認してください。</p>

        <p>一部のデータ型は、照合や自動インクリメントなど、テーブル作成中に適用できるプロパティを提供します。照合により、ユーザーは文字列比較のために大文字と小文字の区別、アクセントの感度、スペーストリミングなどのオプションを設定できます。数値データ型の場合、アイデンティティと自動インクリメントオプションは、サロゲートキー（後のセクションで説明）に便利な一意のシーケンスを生成します。</p>

        <p>ストレージと圧縮に加えて、属性列の適切な型指定は、データロード中の一貫した形式（数値列の迷走文字や日付の不適切な日付形式など）を確保することにより、使いやすさの観点から利点を提供します。それを超えて、適切な型指定により、日付のDATEDIFF（2つの日付の差を計算する）や文字列のSTRTOK（特定の文字列をトークン化し、要求された部分を返す）など、Snowflakeがサポートするすべての関連データ型関数が解除されます。完全なSQL関数リファレンスは、Snowflakeドキュメント（https://docs.snowflake.com/en/sql-reference-functions.html）にあります。</p>

        <div class="info-box">
            <h4>Snowflakeでの文字列の保存</h4>
            <p>SnowflakeはVARCHARデータ型を使用して文字列値を保存します。VARCHAR列の最大長は16 MBまたは16,777,216文字/バイトです。16 MBにはどれくらいのデータが収まりますか？トルストイの「戦争と平和」（587,287語）の内容を4回分はどうでしょうか？興味深いことに、16 MBの長さもデフォルトです。しかし、慌てないでください。Snowflakeは列の内容を正確な長さに効率的に圧縮し、16 MBの最大値に対して請求しません。ただし、その内容が指定された設定を超えることを意図していないことをデータベースユーザーに通知するために、列を固定文字セットに明示的に制限することは理にかなっている場合があります（たとえば、ISO通貨コードを含む列をVARCHAR(3)に設定する）。</p>
        </div>

        <p>では、構造化列から半構造化データ型に目を向けましょう。</p>

        <h3>半構造化データの保存</h3>

        <p>Snowflakeは、半構造化データの処理における容易さと敏捷性で広く認識されています。半構造化情報を保存するために利用可能な3つの専用データ型（VARIANT、ARRAY、OBJECT）があり、それぞれに利用可能な固有の関数（まもなく説明する）を除いて、ユーザーは事前にデータを変換またはフラット化することなく、ネイティブSQLを使用して半構造化コンテンツをクエリできます。半構造化データのクエリについては、後の章で説明し、Snowflakeドキュメント（https://docs.snowflake.com/en/user-guide/querying-semistructured.html）で説明されています。</p>

        <p>Snowflakeテーブルは、構造化データ型と半構造化データ型で構成でき、同じSELECTステートメントでネイティブにクエリできます。ただし、3つの半構造化データ型とそれらの使用方法にはいくつかの違いがあるので、それらが何であるかを理解しましょう：</p>

        <ul>
            <li><strong>VARIANT</strong>：これは、ユーザーがJSON、Avro、ORC、およびParquetデータを変換したり、その構造を明示的に記述したりすることなくロードおよびクエリできるようにする階層型半構造化データの推奨データ型です。VARIANTの最大長は16 MBで、他のデータ型（VARIANTを除く）の値を保存できます。VARIANTデータ型の一般的な用途には、電子メールログ、Webアクティビティ、およびイベントデータが含まれます。</li>
            <li><strong>OBJECT</strong>：Snowflake OBJECTは、他のプログラミング言語で知られているJSONオブジェクトまたは辞書、ハッシュ、またはマップに類似しています。OBJECTはキーと値のペアで、キーは値を識別するVARCHARテキストであり、値自体はVARIANT型です。OBJECTは、キー（名前）が意味のある情報を伝える場合（たとえば、使用されるISO通貨コード別の国のリスト）に使用されます。OBJECTの最大サイズは16 MBで、OBJECTを含む他のデータ型の値を保存できます。</li>
            <li><strong>ARRAY</strong>：Snowflake ARRAYは、他のプログラミング言語の配列に似ています。配列には、ゼロ以上の要素（長さは動的で、明示的に設定されない）とその位置への参照が含まれます。（キー）名でアクセスされる要素を持つOBJECTとは異なり、ARRAY要素はその位置によって参照されます。これにより、ARRAYデータ型は、自然/時系列順でデータをループまたは処理するのに適しています。OBJECTの最大長は16 MBで、ARRAYを含む他のデータ型の値を保存できます。ただし、ARRAYの位置は16 MBの制限に寄与するため、実効サイズは小さくなります。</li>
        </ul>

        <p>Snowflakeのさまざまな構造化および半構造化データ型を取り巻く利用可能なオプションと関数については、簡単に触れただけです。Snowflakeデータ型に関する詳細については、次のドキュメントでそれぞれのセクション別リファレンスを提供しています：https://docs.snowflake.com/en/sql-reference/data-types.html。</p>

        <p>属性列を定義するためのデータ型を理解したので、それらに定義できるさまざまな制約について学習できます。ただし、制約を詳しく調べる前に、Snowflakeの管理に関する1つの重要な要素を強調する必要があります。</p>

        <h2>制約と強制</h2>

        <p>この章の残りの部分はテーブル制約を扱うので、それらが何であるか、およびSnowflakeでの使用に関するいくつかの重要な詳細について理解する必要があります。ANSI-SQL標準では、制約はテーブルに保存されたデータの整合性と一貫性ルールを定義します。Snowflakeは4つの制約タイプをサポートしています：</p>

        <ul>
            <li>PRIMARY KEY</li>
            <li>UNIQUE</li>
            <li>FOREIGN KEY</li>
            <li>NOT NULL</li>
        </ul>

        <p>これらの各制約の機能はこの章の後半でカバーされるため、このセクションはそれらの強制に限定されます。</p>

        <p>データベース側の強制とは、テーブルでDML操作が実行されたときに、特定の制約の整合性ルールを積極的に監視することを意味します。制約を強制することにより、データベースは制約に違反したときにエラーが発生し、違反するDML操作の完了が許可されないことを保証します。</p>

        <p>たとえば、列のNOT NULL制約は、この列にNULL値を含めることができないことを示します。この制約を強制することにより、操作がその列にNULL値を挿入または更新しようとすると、Snowflakeはエラーを発生させます。</p>

        <p>NOT NULLの例は戦略的に選択されました。なぜなら、既存の4つの制約のうち、これが強制される唯一のものだからです。他の3つの制約は指向的であり、強制されていない（エラーを発生させることなく違反できる）一方で、データベースユーザーにいくつかの貴重なメタデータの詳細（この章の後半で説明）を通知します。少なくとも、ハイブリッドUnistoreテーブルが発表される前はそうでした。</p>

        <p>ハイブリッドUnistoreテーブル（前の章で説明）は、Snowflakeが4つの制約すべてを強制できるようにする、まったく異なるHTAPアーキテクチャを持っています。</p>

        <p>これを念頭に置いて、PRIMARY KEY制約を見て、この制約が強制の有無にかかわらず果たす機能を理解しましょう。</p>

        <h2>主キーとしての識別子</h2>

        <p>テーブルは、関連するデータ型の属性を使用してビジネスエンティティの情報を保存します。CUSTOMERテーブルの行は特定の顧客の情報を保持し、ORDERSテーブルの行は注文を表します。あるいはそうでしょうか？おそらくこの例では、注文に複数の製品を含めることができ、同じ数の行にまたがることができます。エンティティの一意のインスタンスを決定するために、識別子（物理データベースを参照する場合は主キー（PK））が使用されます。</p>

        <p>PKは、値がエンティティのインスタンスを一意に決定する列または列のセットです。テーブルごとに定義できるPKは1つだけです。ビジネスの観点から、PKは単一のエンティティインスタンスを表します。前の例に戻ると、注文は1つの製品を含む単一の行ですか、それとも私たちの組織では注文ごとに複数の製品を許可していますか？PKは、テーブルレベルでその現実がどのように見えるかをデータベースユーザーに通知します。</p>

        <p>次の図は、架空のORDERSテーブルからのサンプルデータを示しています。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_007.jpg" alt="図5.7 – ORDERSテーブルからのサンプルデータ" style="max-width: 100%; height: auto;">
            <figcaption>図5.7 – ORDERSテーブルからのサンプルデータ</figcaption>
        </figure>

        <p>O_ORDERKEY列に重複する値がないように見えますが、これは数百万のレコードを持つテーブルからの小さなサンプルです。データを見るだけで、注文がO_ORDERKEYのみ、O_ORDERKEYとO_PRODKEYの組み合わせ、または列の他の組み合わせ（PKが複数の列で構成される場合、複合キーまたは複合キーと呼ばれます）によって一意に識別されるかどうかを判断することは不可能です。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_008.jpg" alt="図5.8 – ORDERSテーブルで定義された単一または複合PK" style="max-width: 100%; height: auto;">
            <figcaption>図5.8 – ORDERSテーブルで定義された単一または複合PK</figcaption>
        </figure>

        <p>テーブル内のすべてのレコードを確認し、重複が見つからなくても、ビジネスモデルと対応するデータモデルが図5.8のシナリオ2のように構成されている場合、後で重複が到着しないという保証はありません。概念的な識別子を確立し、対応するSnowflakeテーブルで物理的に定義することによってのみ、ユーザーはその中で一意のエンティティインスタンスを分離する方法を確実に知ることができます。</p>

        <p>PKが一意のレコードを識別するために使用される方法を理解したので、それを使用する実際的な利点について説明しましょう。</p>

        <h3>PKの利点</h3>

        <p>PKを支持する最も説得力のある議論は、教科書からではなく、Dr. Seussによる子供向けの詩「Too Many Daves」から来ています。この詩は、McCave夫人と彼女の貧しいライフスタイルの選択について語っています。23人の子供を持ち、全員をDaveと名付けたなどです。したがって、一意の識別子がなければ、McCave夫人はDaveの単一のインスタンスを分離することができません。これは、多くのデータベースユーザーにとってあまりにも馴染みのある問題です（https://allpoetry.com/poem/11575842-Too-Many-Daves-by-Theodor-Seuss-Geisel）。</p>

        <p>探しているDaveを分離する以外に、PKを定義する他の説得力のある理由があります。</p>

        <h4>粒度の決定</h4>

        <p>データがテーブルに入力されると、個々のエンティティをクエリしたり、エンティティ統計を集計したりする必要がすぐに続きます。ただし、ユーザーは単一のレコードを構成する行数をどのように判断できますか？注文は単一の行に保存されていますか、それとも含まれる製品ごとに1行を生成しますか？言い換えれば、最低レベルの詳細は何ですか？</p>

        <p>PKは、テーブルの粒度を定義し、含まれるデータの最低レベルとエンティティインスタンスを一意に識別する方法をユーザーに伝えることで、この質問に答えます。</p>

        <p>テーブルのPKを知ることで、データベースユーザーは必要な列と値でデータを正確にクエリし、あいまいさ（たとえば、複数のDaveを持つ）を排除できます。</p>

        <p>一意のエンティティを分離する精度は、そのメトリック（数値属性）をカウントおよび要約するためのテーブルデータの集計にも適用されます。Snowflakeは、テーブルデータを要約するためのさまざまな集計関数（COUNT、SUM、MAXなど）を提供しますが、GROUP BYステートメントでエンティティの一意の識別子（または他のグループ化ディメンション）を指定する必要があります。テーブルの有効な識別子を誤って指定（または想定）すると、誤ったカウントと集計を返すクエリになります。</p>

        <h4>正しい結合結果の確保</h4>

        <p>クエリでは、あるテーブルからのデータを別のテーブルからの情報で結合および充実させる必要があることがよくあります。結合には多くのタイプ（LEFT、INNER、FULL）がありますが、ユーザーは、あるテーブルの行を別のテーブルの一致する行数で乗算するデカルト結合またはクロス結合を避ける傾向があります。デカルト結合は、結合に関与する1つまたは両方のテーブルで一意のレコードを正しく識別できないために最も頻繁に発生します。</p>

        <p>Dr. Seussの例では、あいまいさにより、1行ではなく23行になります。クエリが数百万のレコードで動作する可能性があるデータベースでは、予期しないレコードの爆発により、数十億の余分な行と意味のない最終結果が生じる可能性があります。このようなクエリは、正しい結合条件下で予想されるよりも指数関数的に長く実行される可能性があります。どのデータベースでも、これは完全に時間の無駄になりますが、Snowflakeでは、これには多額のクレジット支出も伴います。</p>

        <h4>重複値の回避（ハイブリッドUnistore）</h4>

        <p>PKはエンティティを一意に識別します。したがって、PK列の重複値はこの制約に違反し、許可されるべきではありません。ただし、ハイブリッドUnistoreテーブルのみがこのルールを強制できます。DML操作を実行するときに既存の値を効率的にスキャンできるインデックスを介してそれを行うことができます。</p>

        <p>通常のSnowflakeテーブルを使用している場合、DML操作の前後にアドホック検証を実行して、重複をテストできます。</p>

        <p>Dr. Seussは、詩を論理的な結論に導き、McCave夫人が子供たちに一意の名前を付けることで多くの困難を回避できたと言っています。「しかし、彼女はそれをしませんでした。そして今では手遅れです。」しかし、子供に名前を付けるのとは異なり、テーブルにPKを割り当てるのに遅すぎることはありません。Snowflakeがそうするための3つの方法を見てみましょう。</p>

        <h3>PKの指定</h3>

        <p>PKは、Snowflakeテーブルを作成するときに2つの方法のいずれかで指定できます。CREATE TABLEステートメントの対応する列の横にインライン、またはその最後にアウトオブラインで：</p>

        <ul>
            <li><strong>新しいテーブルインライン</strong>：テーブルを作成するときに、対応する列の横にPKを直接宣言できます。この方法は、単一列のPKに対してのみ有効であり、複合キーを定義するために使用することはできません：</li>
        </ul>

        <pre><code>CREATE TABLE ORDERS
(
    O_ORDERKEY number(38,0) CONSTRAINT my_pk_name PRIMARY KEY,
    O_PRODUCTKEY number(38,0) NOT NULL,
    O_CUSTKEY number(38,0) NOT NULL,
    -- < 残りの列>
    O_COMMENT varchar(200) COMMENT '注文の詳細'
);</code></pre>

        <ul>
            <li><strong>新しいテーブルアウトオブライン</strong>：この方法により、SnowflakeユーザーはCREATEステートメントの最後でPKを指定し、定義の一部として複数の列を含めることができます：</li>
        </ul>

        <pre><code>CREATE TABLE ORDERS
(
    O_ORDERKEY number(38,0),
    O_PRODUCTKEY number(38,0),
    O_CUSTKEY number(38,0) NOT NULL,
    -- < 残りの列>
    O_COMMENT varchar(200) COMMENT '注文の詳細',
    CONSTRAINT my_pk_name PRIMARY KEY ( O_ORDERKEY, O_PRODUCTKEY )
);</code></pre>

        <ul>
            <li><strong>既存のテーブルアウトオブライン</strong>：PKは、ALTER TABLEステートメントを実行し、アウトオブライン制約のように指定することで、既存のテーブルに対して定義できます：</li>
        </ul>

        <pre><code>ALTER TABLE ORDERS
ADD CONSTRAINT my_pk_name PRIMARY KEY (O_ORDERKEY,
O_PRODUCTKEY);</code></pre>

        <p>PKを定義する方法を見たので、存在するさまざまな種類のキーと、モデリングでの使用方法について説明しましょう。</p>

        <h3>キーの分類</h3>

        <p>PKがデータベーステーブルの定義とクエリで果たす重要な役割を見てきたので、存在するさまざまな種類のキーをドリルダウンして、その分類法と、テーブルを設計するときに果たす役割を理解する時が来ました。</p>

        <p>PKの機能は変わりませんが（テーブル内のレコードを一意に識別するため）、モデリングの言語では、キー列の性質に基づいて区別できます。それが実際にどのように見えるかを見てみましょう。最も一般的なタイプであるビジネスキーから始めます。</p>

        <h4>ビジネスキー</h4>

        <p>ビジネスキーは、その値が組織内で意味または重要性を持つPKです。文字のランダムなグループは、一意である限り、エンティティインスタンスを識別するのに役立ちます。ビジネスキーを際立たせるのは、その値自体が重要であることです。</p>

        <p>この章のすべての例はビジネスキーでした。図5.7の例では、O_ORDERKEYとO_PRODKEYの値は、運用チームとそのシステムの組織内で理解され、同じコードがCRMシステムや存在する他のテーブルで参照されます。PKとして使用される場合、社会保障番号またはISO国コードも、外部世界でのより広い意味のためにビジネスキーとして適格です。</p>

        <p>ビジネスキーを含む列をモデリングする場合、区別を指定するためにBKEYのプレフィックスまたはサフィックスがよく使用されます。</p>

        <p>ただし、テーブル設計で有用であるためには、キーにビジネス上の意味がある必要はありません。サロゲートキーに会いましょう。</p>

        <h4>サロゲートキー</h4>

        <p>ビジネス上の意味を持つビジネスキーとは異なり、サロゲートキーは値に特別な意味を持たないPKです。サロゲートキーは通常、ランダム文字、列ハッシュ、または連続した整数を使用して作成されます。一意性の条件を満たしていますが、その値には本質的な意味がありません。</p>

        <p>テーブルには、多数のメンバー列を持つ複合PKがあることが多く、たとえばあるテーブルを別のテーブルに結合する必要がある場合に、入力が面倒になります。サロゲートキーは、本質的に単一列であり、標準の値形式（列ハッシュやシーケンスなど）を持っているため、この不便さを回避します。後の章で説明するData Vault 2.0などの一部のデータモデルは、テーブル設計を反復可能で一貫性のあるものにするために、厳密な命名と値パターンを確保するためにサロゲートキーに依存しています。</p>

        <p>サロゲートキーを含む列をモデリングする場合、区別を指定するためにSKEYのプレフィックスまたはサフィックスがよく使用されます。</p>

        <div class="info-box">
            <h4>シーケンス</h4>
            <p>連続したサロゲートキーを作成する場合、Snowflakeはシーケンスと呼ばれるメカニズムを提供します。シーケンスは、連続した（ただし、必ずしもギャップがないわけではない）整数を生成し、一意の列値を保証する独立したデータベースオブジェクトです。シーケンスを作成するときに、開始番号と増分を指定できます。</p>
            
            <p>独立したオブジェクトとして、単一のシーケンスを複数のテーブルで共有したり、関数呼び出しを通じて操作したりできます。</p>
            
            <p>シーケンスは、テーブルを作成するときにデフォルトの列値として割り当てることで、サロゲートキーとして使用できます。これを行うには、次のようにシーケンスのnextval関数を列のデフォルトとして使用します：</p>
        </div>

        <pre><code>create or replace sequence seq1;
create or replace table foo (k number default seq1.nextval, v number);</code></pre>

        <p>次の例は、nextval関数のさまざまな条件下で新しいレコードがどのように動作するかを示しています：</p>

        <pre><code>-- 一意のキー（seq1によって生成）と明示的な値を持つ行を挿入
insert into foo (v) values (100);
insert into foo values (default, 101);
-- 一意のキー（seq1によって生成）と再利用された値を持つ行を挿入。
-- 新しいキーは既存のキーとは異なります。
insert into foo (v) select v from foo;
-- 両方の列に明示的な値を持つ行を挿入
insert into foo values (200, 202);
select * from foo;
+------+------+
|    K |    V |
|------+------|
|    1 |  100 |
|    2 |  101 |
|    3 |  100 |
|    4 |  101 |
|  200 |  202 |
+------+------+</code></pre>

        <p>または、Snowflakeは、列を作成するときにAUTOINCREMENTまたはIDENTITYキーワードを使用して、特定のテーブルのシーケンスオブジェクトを透過的に作成および管理できます：</p>

        <pre><code>CREATE TABLE FOO
(
    k number DEFAULT seq1.nextval,
    v number
);
CREATE TABLE BAR
(
    k number NOT NULL AUTOINCREMENT START 10 INCREMENT 5,
    v number NOT NULL
);</code></pre>

        <p>シーケンスの使用に関する詳細については、Snowflakeのドキュメントを参照してください：https://docs.snowflake.com/en/user-guide/querying-sequences。</p>

        <p>PK分類法を理解し、ビジネス上の意味を持つビジネスキーと、それ自体に意味がなく、唯一の目的が一意の値を提供することであるサロゲートキーを区別できるようになりました。ただし、テーブルに定義できるPKは1つだけであることを思い出してください。では、エンティティインスタンスを一意に識別できる複数の列がある場合はどうなりますか？</p>

        <h2>一意制約としての代替キー</h2>

        <p>EMPLOYEE_ID列（一意のビジネス識別子）と社会保障番号（政府発行の個人識別子）を含むEMPLOYEEテーブルをモデリングしていたとします。どちらの列も、EMPLOYEEテーブル内のレコードを一意に識別するPK要件を満たしますが、テーブルには1つのPKのみを割り当てることができることを思い出してください。PKがすでに存在する場合に、別の列（または列）がPKの条件を満たしていることをデータベースユーザーに知らせるために、代替キー（AK）またはUNIQUE制約も定義できます。</p>

        <p>前の例では、EMPLOYEEテーブルには2つの有効なPK候補がありました：EMPLOYEE_IDとSOCIAL_SECURITY_IDです。OLTPデータベースでは、組織のビジネスキーとして機能する列を主キーにする必要があります。複数のソースシステムからのビジネスキーがロードされる可能性があるデータウェアハウスでは、代わりにサロゲートキーが使用されます。この規則により、EMPLOYEEテーブルは、EMPLOYEE_IDをPKとして、SOCIAL_SECURITY_IDをAK（UNIQUE）としてモデル化する必要があります。</p>

        <p>次の例は、それがどのように見えるかを示しています：</p>

        <pre><code>CREATE TABLE EMPLOYEE
(
    EMPLOYEE_ID varchar(10),
    SOCIAL_SECURITY_ID number(9),
    -- < 残りの列>
    NAME varchar,
    CONSTRAINT pk_employee PRIMARY KEY ( EMPLOYEE_ID ),
    CONSTRAINT ak_employee UNIQUE (SOCIAL_SECURITY_ID)
);</code></pre>

        <p>PKとは異なり、テーブルには必要な数のAKを含めることができます。AKは、テーブルの粒度とそのさまざまな列に関する洞察をデータベースユーザーに提供し、PKと同じ機能上の利点を持っています。PKと同様に、UNIQUE制約はハイブリッドUnistoreテーブルでのみ強制され、標準のテーブルでは単に指向的です。</p>

        <p>これまで、この章では個々のテーブルとその制約に焦点を当ててきましたが、モデリングは、多くのビジネスエンティティの相互に関連する性質を表すデータベースランドスケープ全体を定義することに関係しています。次のセクションでは、エンティティ間の関係を形成する方法と、これがデータベースモデルの重要な詳細である理由を説明します。</p>

        <h2>外部キーとしての関係</h2>

        <p>どのビジネスも、エンティティのセットとその相互作用に分解できます。たとえば、顧客は、アクティブなマーケティングキャンペーンからのプロモーションコードを適用しながら、サプライヤーが提供するアイテムの注文を行います。これは、典型的な組織で行われていることのごく一部にすぎません。これまで、この章ではエンティティ自体（注文、アイテム、サプライヤーなど）に焦点を当ててきました。今度は、相互作用（モデリング用語では関係と呼ばれる）に焦点を当てる時です。注文の配置、アイテムの提供、プロモーションの適用などです。</p>

        <p>ビジネスエンティティが関連している場合、対応するテーブルには相互作用の詳細をキャプチャする方法が必要です。顧客がアイテムを注文すると、注文の詳細には、顧客が誰であるか、どのアイテムを注文したかをキャプチャする必要があります。PKはテーブル内の一意のレコードを識別することを思い出してください。したがって、2つのテーブルが関係を共有する場合、一方のPKを他方に含めて、相互作用の詳細を保存する必要があります。データベースでは、この関係は外部キー（FK）と呼ばれるテーブル制約を通じて確立されます。</p>

        <p>あるテーブル（親と呼ばれる）のPK列が別のテーブル（子と呼ばれる）に含まれる場合、子テーブルでFK制約を宣言して関係を正式化できます。FK制約は、データベースとそのユーザーに、2つのテーブルに共通の列があることは偶然ではなく、ビジネスコンテキストを通じて関係を共有していることを伝えます。</p>

        <p>FKは、親テーブルを子に接続する線によって図に表されます。第1章「モデリングの力を解き放つ」のPERSONとACCOUNTの例を思い出してください。そこでは、アカウントは人に割り当てられなければならず、人はゼロまたは多くのアカウントを開くことができることが確立されました。PERSON_IDがPERSON（そのPK）を一意に識別することが確立されている場合、この列をACCOUNTテーブルに含めてFK制約として宣言する必要があります。ACCOUNTテーブル（子テーブル）を作成するときは、PKとFK制約の両方を定義する必要があります。</p>

        <p>次のコードスニペットは、PERSONテーブルとACCOUNTテーブルの作成を示しています：</p>

        <pre><code>CREATE TABLE PERSON
(
    PERSON_ID number(8,0) NOT NULL,
    SOCIAL_SERCURITY_NUM number(9,0) NOT NULL,
    DRIVERS_LICENSE varchar(10) NOT NULL,
    NAME varchar NOT NULL,
    BIRTH_DATE date NOT NULL,
    CONSTRAINT PK_1 PRIMARY KEY ( PERSON_ID )
);
CREATE TABLE ACCOUNT
(
    PERSON_ID number(8,0) NOT NULL,
    ACCOUNT_ID varchar(12) NOT NULL,
    ACCOUNT_TYPE varchar(3) NOT NULL,
    IS_ACTIVE boolean NOT NULL,
    OPEN_DATE date NOT NULL,
    CLOSE_DATE date,
    CONSTRAINT PK_2 PRIMARY KEY ( PERSON_ID, ACCOUNT_ID ),
    CONSTRAINT FK_1 FOREIGN KEY ( PERSON_ID ) REFERENCES PERSON (    PERSON_ID )
);</code></pre>

        <p>人間がこの関係をより簡単に認識できるようにする結果の図は、第1章「モデリングの力を解き放つ」で最初に示したものです：</p>

        <figure>
            <img src="../images/chapter5/B19467_05_009.jpg" alt="図5.9 – 関係を共有する2つのテーブル" style="max-width: 100%; height: auto;">
            <figcaption>図5.9 – 関係を共有する2つのテーブル</figcaption>
        </figure>

        <p>前のDDLで定義され、図5.10で表現されたPKとFKは、アカウント開設に関するビジネスルールがデータベース設計に焼き付けられていることを保証します。</p>

        <p>そのようなモデルが含む可能性のあるデータを示すために、結果のテーブルのサンプル値が次の図に示されています。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_010.jpg" alt="図5.10 – PERSONおよびACCOUNTテーブルのサンプル値" style="max-width: 100%; height: auto;">
            <figcaption>図5.10 – PERSONおよびACCOUNTテーブルのサンプル値</figcaption>
        </figure>

        <p>データベースでは、FKからPKへの参照が最も一般的な形式の関係ですが、唯一の形式ではありません。FKはAKを参照することもできます。多くの場合、テーブルにはPKとしてサロゲートキーがあり、さまざまなビジネスキーがAKとして宣言されています。サロゲートキーはビジネス価値のない技術的な成果物であるため、関連するテーブルは代わりに代替ビジネスキーを参照します。次の例に示すように：</p>

        <figure>
            <img src="../images/chapter5/B19467_05_011.jpg" alt="図5.11 – AKを参照するFK" style="max-width: 100%; height: auto;">
            <figcaption>図5.11 – AKを参照するFK</figcaption>
        </figure>

        <p>添付のコードでわかるように、FKのAKを参照する構文は、PKを参照するために使用される構文と同じです：</p>

        <pre><code>CREATE OR REPLACE TABLE employee
(
    employee_skey      integer NOT NULL AUTOINCREMENT START 1     INCREMENT 1,
    employee_bkey      varchar(10) NOT NULL,
    name               varchar NOT NULL,
    social_security_id number(8,0) NOT NULL,
    healthcare_id      integer NOT NULL,
    birth_date         date NOT NULL,
    CONSTRAINT pk_employee_skey PRIMARY KEY ( employee_skey ),
    CONSTRAINT ak_employee_bkey UNIQUE ( employee_bkey ),
    CONSTRAINT ak_healthcare_id UNIQUE ( healthcare_id ),
    CONSTRAINT ak_ss_id         UNIQUE ( social_security_id )
);
CREATE OR REPLACE TABLE employee_of_the_month
(
    month         date NOT NULL,
    employee_bkey varchar(10) NOT NULL,
    awarded_for   varchar NOT NULL,
    comments      varchar NOT NULL,
    CONSTRAINT pk_employee_of_the_month_month PRIMARY KEY ( month ),
    CONSTRAINT fk_ref_employee FOREIGN KEY ( employee_bkey )
    REFERENCES employee ( employee_bkey )
);</code></pre>

        <p>FKが何であるかを理解したので、その利点について理解しましょう。</p>

        <h3>FKの利点</h3>

        <p>FKを宣言すると、2つのテーブル間の機能的な関係が正式化されます。このメタデータは現在、データモデルの一部となり、データベースを使用する誰でも参照できます。これがもたらす利点の一部を次に示します。</p>

        <h4>データモデルの視覚化</h4>

        <p>人間は、認知を強化するために視覚化を使用します。前のセクションでは、単純な図がコードに保存されている同じ情報をより速く、より詳細に伝達する方法を示しました。今度は、2つのテーブルからデータベーススキーマ全体に移行することを想像してください。エンティティと関係のマッピングに役立つ視覚的なガイドラインがなければ、事前の知識なしにすべてのテーブルとその内容を理解することは困難です。</p>

        <p>次の図は、2つのテーブルから20に移行すると図上でどのように見えるかを示しています。エンタープライズシステムのデータモデルが数百、数千ではないにしても、数百のテーブルにまたがる可能性があることを考慮すると、図の助けはビジネス/データランドスケープをナビゲートする上で非常に貴重になります。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_012.jpg" alt="図5.12 – 2つのテーブルからスキーマ全体へ" style="max-width: 100%; height: auto;">
            <figcaption>図5.12 – 2つのテーブルからスキーマ全体へ</figcaption>
        </figure>

        <p>ただし、テーブル間の関係は単なる視覚的な補助ではありません。クエリを書くための実用的な目的を果たします。</p>

        <h4>結合の通知</h4>

        <p>FKを定義するには、ユーザーが親PK列と対応する子テーブルの列との間の参照を指定する必要があります。これは、2つのテーブル間のリンクがデータモデルに焼き付けられ、分析または変換のためにテーブルデータを結合したいユーザーが参照できることを意味します。</p>

        <p>次の図は、FK関係が2つのテーブル間の共通列（PERSON_ID）を強調表示する方法を示しています。</p>

        <figure>
            <img src="../images/chapter5/B19467_05_013.jpg" alt="図5.13 – 結合条件を推測するためのFK列の強調表示" style="max-width: 100%; height: auto;">
            <figcaption>図5.13 – 結合条件を推測するためのFK列の強調表示</figcaption>
        </figure>

        <p>現在、ユーザーはこのメタデータを活用して、PERSON_IDを使用して2つのテーブルを結合することにより、PERSONおよびACCOUNTデータを取得するクエリを記述できます。</p>

        <p>ただし、FKは人々にとってだけでなく、ビジネスインテリジェンス（BI）ツールもそれらを活用します。</p>

        <p>さらに重要なことに、Snowflakeは、結合が不要な場合にこれらの詳細を活用して結合の実行を回避し、パフォーマンスを向上させることができます（これとRELYプロパティの詳細については、第12章「変換モデリングの実践」を参照）。</p>

        <h4>BIツールでの機能の自動化</h4>

        <p>多くのBIツールは、FKを使用してユーザビリティを向上させ、ユーザーの時間を節約します。たとえば、TableauやPower BIなどのダッシュボードおよび分析ツールは、FKを検出して、ユーザーからの明示的な支援なしにテーブル間の結合を自動的に作成するために使用します。</p>

        <p>モデリングツールと一部のSQL IDEは、データベースDDLを読み取ることでER図を生成できます。すべてのデータベースオブジェクトには対応するCREATEステートメントがありますが、ER図は、CREATEステートメントで表されるオブジェクトがFKを通じても関連している場合にのみ意味があります。</p>

        <p>次に説明する利点は、FK制約を強制することによってのみ可能であるため、ハイブリッドUnistoreテーブル用に予約されています。ただし、Snowflakeプラットフォームでユーザーが認識すべき強力な新しい可能性を解き放ちます。</p>

        <h4>参照整合性の強制（ハイブリッドUnistore）</h4>

        <p>前述のように、FK関係は純粋に指向的ではなく、データベース規則を通じてビジネスルールを正式化します。ACCOUNTはPERSON_IDなしで開設できないと規定された以前の例を思い出してください。では、新しいアカウントが作成されたとき、データベースはPERSON_IDが提供されていること、さらに重要なことに、それがPERSONテーブルの有効なレコードに対応していることをどのように保証できますか？FK制約を強制することによって。</p>

        <p>データベースがFK制約を強制すると、子テーブルで使用される一意の識別子が親に存在することを確認します。これは参照整合性として知られる条件です。参照整合性により、子テーブルのFK値が親の有効なレコードに対応することが保証されます。データベースに存在しない人のアカウントを開設することは意味がないのと同じように、参照整合性チェックにより、DML操作が誤った異常なデータにならないことが保証されます。</p>

        <p>PK制約を強制するのと同じように、FK強制は参照整合性チェックを迅速に実行するためのインデックスの存在に依存しているため、ハイブリッドUnistoreテーブルでのみ可能です（手動で実行しない限り）。</p>

        <p>強制されているかどうかにかかわらず、FKを使用する説得力のある理由は多くあります。最後にカバーする制約は、すべてのSnowflakeテーブルで強制される唯一の制約であり、ハイブリッドUnistoreだけではないため、その仕組みを学びましょう。</p>

        <h2>NOT NULL制約としての必須列</h2>

        <p>エンティティの属性を定義する際、どれが必須でどれがオプションかという問題が必然的に発生します。ほとんどのモデリングの決定と同様に、答えは技術的なデータベースプロパティよりもビジネスコンテキストに依存します。同じ属性、たとえばCUSTOMERの電子メールアドレスは、オンラインストアでは必須ですが、実店舗の小売業者ではオプションです。後者の場合、電子メールアドレスがないことは販売告知を見逃すことを意味しますが、前者の場合、Webサイトにアクセスできない可能性があります。</p>

        <p>概念モデルから物理的なSnowflake設計に移行する際、必須列はNOT NULL制約を通じて定義できます。NOT NULL制約は、対応する列の横にインラインで宣言され、名前を付ける必要はありません。このため、NOT NULL制約をアウトオブラインで宣言することはできません。</p>

        <p>列にNOT NULL制約を追加する形式は次のとおりです：</p>

        <pre><code>&lt;col1_name&gt; &lt;col1_type&gt; [ NOT NULL ]</code></pre>

        <p>ACCOUNTテーブルなどの以前の例では、NOT NULL制約のインスタンスが示されています。ここでは、CLOSE_DATEがACCOUNTテーブルで必須ではない唯一の列であり、NULL値を持つことが許可されていることがわかります：</p>

        <pre><code>CREATE TABLE ACCOUNT
(
    PERSON_ID number(8,0) NOT NULL,
    ACCOUNT_ID varchar(12) NOT NULL,
    ACCOUNT_TYPE varchar(3) NOT NULL,
    IS_ACTIVE boolean NOT NULL,
    OPEN_DATE date NOT NULL,
    CLOSE_DATE date,
    CONSTRAINT PK_2 PRIMARY KEY ( PERSON_ID, ACCOUNT_ID ),
    CONSTRAINT FK_1 FOREIGN KEY ( PERSON_ID ) REFERENCES PERSON (    PERSON_ID )
);</code></pre>

        <p>他の制約とは異なり、NOT NULLの強制には、他のテーブルへのルックアップや参照は必要ありません。指定された列の値をチェックすることで、個々の行で直接実行できます。このため、NOT NULLはすべてのSnowflakeテーブルに対して強制され、DML操作中にパフォーマンスのオーバーヘッドは発生しません。</p>

        <h2>まとめ</h2>

        <p>この章では、論理モデリングの概念から物理的なSnowflakeオブジェクトに移行する方法について説明しました。このプロセス中に、Snowflakeがほぼ無限のサイズのテーブルを管理可能なマイクロパーティションに分割して処理する方法と、これらのパーティションをクラスター化してクエリとDMLのパフォーマンスを最適化する方法を学びました。</p>

        <p>その後、Snowflakeのデータ型とそのプロパティを理解することで、属性を定義する方法を学びました。Snowflakeは、データ型を扱いやすく、より高性能にするためのさまざまな関数を提供しており、半構造化データ用に提供する強力なオプションは言うまでもありません。</p>

        <p>個々の制約タイプに飛び込む前に、データベース制約とは何か、およびSnowflakeが適用されるテーブルのタイプに応じてそれらをどのように整理および強制するかを理解しました。</p>

        <p>一意の識別子がテーブルの定義にとって重要である理由と、SnowflakeがPK制約を通じてこれをどのように管理するかを見ました。PKは、テーブル内の最小レベルの詳細を識別し、正確な検索と結合を保証することで、データベースユーザーの生活を楽にするのに役立ちます。また、PKに複数の候補が存在する場合、UNIQUE制約を通じてAKを定義でき、同じ利点を提供することも見ました。</p>

        <p>次に、FK制約を定義することで、物理データベースで関係がどのように正式化されるかを見ました。FKは、テーブル間の機能的な関係をキャプチャすることで、複雑なデータランドスケープを視覚化およびナビゲートすることを可能にします。これは、データベースの人間のユーザーとBIツールが頻繁に活用する情報です。</p>

        <p>最後に、必須列を宣言し、NOT NULL制約を使用してルールを強制してデータ品質を確保する方法を学びました。</p>

        <p>この章や他の章では、例を明確にし、抽象的な概念を説明するために、リレーショナル図に頻繁に依存してきました。ただし、モデリング記法の正式な説明や、視覚的なモデリングツールキットのさまざまな要素の概要はありませんでした。論理レベルと物理レベルでデータモデルのコア要素を理解したので、次の章では、あらゆる規模でデータモデルを設計または視覚化するためのモデリング記法に焦点を当てます。</p>

        <div class="nav-links">
            <a href="chapter4.html">← 第4章：Snowflakeオブジェクトをマスターする</a>
            <a href="chapter6.html" style="float: right;">第6章：モデリング記法を通じたSnowflakeアーキテクチャの理解 →</a>
        </div>

        <footer>
            <p>&copy; 2024 SnowflakeによるデータモデリングLab. このコンテンツは個人学習用です。</p>
        </footer>
    </div>
</body>
</html>