<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noodp, noimageindex">
    <meta name="googlebot" content="noindex, nofollow">
    <title>第4章：Snowflakeオブジェクトをマスターする - SnowflakeによるデータモデリングLab</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <nav>
        <ul>
            <li><a href="../index.html">ホーム</a></li>
            <li><a href="../preface.html">はじめに</a></li>
            <li><a href="index.html">第1部</a></li>
        </ul>
    </nav>

    <div class="container">

        <h1>第4章：Snowflakeオブジェクトをマスターする</h1>
        
        <div class="notice">
            <div class="notice-title">📖 この章について</div>
            <p>この内容は「Data Modeling with Snowflake」の第4章を、省略することなく完全に日本語に翻訳したものです。</p>
        </div>

        <p>前の章では、Data Cloudを動かし、他のデータベースでは決して可能ではなかった可能性を解き放つ革新的なアーキテクチャを紹介しました。この章では、Snowflakeの顧客がモデリングの旅で使用するデータベースオブジェクトを探求します。テーブルやビューなどのオブジェクトは、以前にSQLを使用したことがあるほとんどの人にとって間違いなく馴染みのあるものですが、ここでもSnowflakeの独自の機能が物理モデルの設計における潜在的な効率性を解き放つため、ユーザーはそれらをよく理解しておく必要があります。</p>

        <p>変動支出価格設定のため、Snowflakeデータモデリングでは、サポートされているオブジェクトとそのパラメーターのコスト/パフォーマンスのトレードオフをユーザーがよく理解していることが必要です。Snowflakeで作業したことがない人にとって、ストリームや外部テーブルなどの独占的な機能はまだ馴染みがないかもしれません。しかし、優れた設計上の決定を下すには、ユーザーがSnowflakeの完全なモデリングツールセットをしっかりと把握し、徹底的に理解することが求められます。</p>

        <h2>この章では、以下の主なトピックを扱います：</h2>

        <ul>
            <li>Snowflakeへのデータロードに使用されるステージとファイルフォーマットオブジェクト</li>
            <li>データを保存するために使用されるさまざまな物理テーブルタイプ</li>
            <li>ステージングされたファイルをレビューするためのメタデータテーブル</li>
            <li>ビューと関連するコストとパフォーマンスの利点</li>
            <li>マテリアライズドビューとその使用時期</li>
            <li>データ変更追跡のためのストリーム</li>
            <li>継続的なETLパイプラインを自動化するためのタスク</li>
        </ul>

        <h2>ステージ</h2>

        <p>データがテーブルに格納される前に、ステージを使用してSnowflakeにロードする必要があります。ステージは、クラウドファイルシステムを抽象化し、Snowflakeにデータをロードするための標準的な方法で使用できるようにする論理オブジェクトです。定義できるステージには、外部と内部の2つのタイプがあります。外部ステージは、Snowflake外部のクラウドロケーション（サポートされているクラウドストレージサービス用）の上に作成でき、外部ソースシステムからデータをロードするために使用されます。内部ステージはSnowflakeアカウント内で作成されるため、ホスティングプロバイダーのストレージタイプを使用します。内部ステージは、Snowflakeアカウント内から発生するファイルをステージングするために使用され、外部データのロードには使用できません。</p>

        <p>外部ステージでサポートされているクラウドストレージサービスは次のとおりです：</p>

        <ul>
            <li>Amazon S3バケット</li>
            <li>Google Cloud Storageバケット</li>
            <li>Microsoft Azureコンテナー</li>
        </ul>

        <p>次の図は、内部ステージタイプに関連する外部ステージのレイアウトを示しています。</p>

        <figure>
            <img src="../images/chapter4/B19467_04_001.jpg" alt="図4.1 – Snowflakeの外部および内部ステージ" style="max-width: 100%; height: auto;">
            <figcaption>図4.1 – Snowflakeの外部および内部ステージ</figcaption>
        </figure>

        <p>マイクロパーティション化され、内部の列形式を使用するテーブルに保存されたデータとは異なり、ステージはあらゆるタイプのファイルを保存できます。Snowflakeへのデータロード用に特定の構造化および半構造化ファイルタイプのみがサポートされていますが、ステージ内の非構造化ファイルの可視性は、外部テーブルおよびディレクトリテーブル（この章の後半で説明）と組み合わせると重要な考慮事項です。</p>

        <p>ステージはさまざまなファイルとファイルタイプを保存できます。ただし、Snowflakeテーブルへの後続のロードのためにステージからデータにアクセスする場合は、ファイルフォーマットを指定する必要があります。</p>

        <h3>ファイルフォーマット</h3>

        <p>ファイルフォーマットは、ファイルへのデータの読み取りまたは書き込みのファイルタイプを記述するテンプレートと考えることができます。ファイルフォーマットは、区切り文字タイプ（カンマ、タブ、その他など）、日付/時刻形式、エンコーディング（Hex Base64、UTF-8など）などのプロパティを定義します。</p>

        <p>Snowflakeは、CSV、JSON、Parquetなど、一般的に使用されるデフォルトを持つ複数の構造化および半構造化ファイルフォーマットを提供します。ただし、ユーザーは指定されたタイプのファイルをロードまたはアンロードする際に、独自の名前付きファイルフォーマットを自由に作成できます。ファイルフォーマットのプロパティは、COPY INTOコマンドを使用する際に実行時に指定することもできます。</p>

        <p>データロード用のサポートされているファイルタイプとファイルフォーマットの説明は、Snowflakeドキュメントで入手できます：https://docs.snowflake.com/en/user-guide/data-load-prepare.html。</p>

        <p>ストリーミングを含むあらゆる種類のデータロードの完全な概要については、Snowflake Webサイトのガイドを参照してください：https://docs.snowflake.com/en/user-guide-data-load.html。</p>

        <p>ステージからファイルフォーマットを使用してSnowflakeにデータがロードされる方法を見たので、それを保存するために使用されるテーブルについて理解しましょう。</p>

        <h2>テーブル</h2>

        <p>Snowflakeのデータはテーブルに保存されます。これは、説明したように、データモデリングの基本的なコンポーネントの1つです。ただし、モデリングのコンテキストでそれらを探求する前に、Snowflakeに存在するさまざまなテーブルタイプとそのコストを理解する必要があります。</p>

        <p>前の章では、削除されたオブジェクトを復元したり、以前の時点でデータをクエリしたりできる機能であるSnowflakeのタイムトラベルについて説明しました。ただし、タイムトラベルには関連するストレージコストがあり、利用可能なタイムトラベル日数（保持期間として知られる）は、まもなく詳しく確認するように、テーブルタイプによって異なります。</p>

        <p>Snowflakeは、フェイルセーフとして知られる管理されたタイプのタイムトラベルも提供します。すべての永続テーブルには7日間のフェイルセーフ期間があります。ユーザーがアクセスできるタイムトラベルとは異なり、フェイルセーフはSnowflakeによって管理され、システム障害やデータ侵害などの災害からユーザーデータを保護するためにSnowflakeのみがアクセスできます。フェイルセーフに保存されたデータを回復するには、ユーザーはSnowflakeに直接連絡する必要があります。</p>

        <p>タイムトラベルとフェイルセーフを提供するテーブルの場合、7日間のフェイルセーフ期間はタイムトラベル期間が終了した直後に開始されます。次の図は、Snowflakeテーブルが提供するデータ保護のタイプと期間を示しています：</p>

        <figure>
            <img src="../images/chapter4/B19467_04_002.jpg" alt="図4.2 – 継続的データ保護ライフサイクル" style="max-width: 100%; height: auto;">
            <figcaption>図4.2 – 継続的データ保護ライフサイクル</figcaption>
        </figure>

        <p>異なるユースケースでは、異なるバックアップ戦略が必要です。トランザクションデータには数日間の履歴が必要な場合がありますが、ステージングテーブルは一時的にのみ必要な場合があります。Snowflakeは、さまざまな保持期間（および関連するコスト）オプションを持つ複数の物理テーブルタイプを提供します。これらには以下が含まれます：</p>

        <ul>
            <li>パーマネント</li>
            <li>トランジェント</li>
            <li>テンポラリー</li>
            <li>ハイブリッドUnistoreテーブル</li>
        </ul>

        <p>Snowflakeは、ステージコンテンツ用のいくつかのメタデータテーブル構造も提供します。これらは、ユーザーが通常のテーブルと同じようにファイルコンテンツとメタデータ（ファイル名など）をクエリできるようにするために、ステージの上に存在するセマンティックオブジェクトです。これらのオブジェクトは読み取り専用であり、次の形式で提供されます：</p>

        <ul>
            <li>外部テーブル</li>
            <li>ディレクトリテーブル</li>
        </ul>

        <p>以下のセクションでは、各テーブルタイプの固有のプロパティについて詳しく説明します。</p>

        <h3>物理テーブル</h3>

        <p>Snowflakeでは、データはスキーマによって論理的にグループ化された物理テーブルに保存されます。テーブルは、名前、データ型、およびオプションの制約とプロパティ（NULL許容性、デフォルト値、主キーなど）を持つ列で構成されます。</p>

        <p>テーブルを作成するためのDDLコマンドはCREATE TABLEであり、指定された構造を持つ空のテーブルをインスタンス化するためにリレーショナルモデリングシナリオで使用されます。</p>

        <p>CREATE TABLEコマンドの他のバリアントは、該当する場合は対応するデータとともに、既存のオブジェクトからテーブルを作成、パターン化、またはクローンするために変換コンテキストで使用されます。これらの操作は、事前にリレーショナルモデル/スキーマが存在する必要があるため（たとえば、既存のテーブルをクローンしてテーブルを作成する）、変換と呼ばれます。サポートされているバリアントは次のとおりです：</p>

        <ul>
            <li><strong>CREATE TABLE AS SELECT</strong>：一般的にCTASと呼ばれ、クエリから返されたデータを含むテーブルを作成します（暗黙のデータ型を使用）。</li>
            <li><strong>CREATE TABLE USING TEMPLATE</strong>：半構造化ファイル（現在、Parquet、Avro、ORC形式でサポート）から派生した列定義を使用して空のテーブルを作成します。</li>
            <li><strong>CREATE TABLE LIKE</strong>：既存のテーブルの列定義を使用して空のテーブルを作成します。列のプロパティ、デフォルト、および制約もコピーされます。</li>
            <li><strong>CREATE TABLE CLONE</strong>：LIKEと同じことを行いますが、ゼロコピークローニングを使用してソーステーブルからすべてのデータも含めます（実際にはコピーしません）。CLONEバリアントは、タイムトラベルと一緒に使用して、過去の特定の時点でデータをクローンできます。クローンされたテーブルは、クローンまたはソースオブジェクトで構造またはコンテンツが変更されるまでストレージを消費しません。</li>
        </ul>

        <p>Snowflakeが提供するさまざまな物理テーブルを見てみましょう。</p>

        <h4>パーマネントテーブル</h4>

        <p>Snowflakeのデフォルトのテーブルタイプはパーマネントテーブルです。これは、テンポラリーテーブルを除くすべてのSnowflakeテーブルが明示的に削除されるまで永続するため、やや誤った名称です。パーマネントテーブルには組み込みのバックアップ機能が付属しています。変更または無効にできない7日間のフェイルセーフ期間と、デフォルトで1日のタイムトラベルが含まれています。パーマネントテーブルのタイムトラベル期間は、無効にすることも、SnowflakeのEnterpriseプランで最大90日まで延長することもできます。</p>

        <p>その広範な回復可能性により、パーマネントテーブルは、災害の場合に再生成するのがコストがかかるか不可能なビジネスクリティカルな情報を保存するための理想的な候補になります。</p>

        <p>パーマネントテーブルを作成するには、次のコマンドを使用できます：</p>

        <pre><code>CREATE TABLE &lt;table_name&gt;</code></pre>

        <p>ただし、すべてのテーブルがバックアップや延長されたタイムトラベル期間を必要とするわけではありません。そのような場合は、代わりにトランジェントテーブルを検討する必要があります。</p>

        <h4>トランジェントテーブル</h4>

        <p>パーマネントテーブルとは異なり、トランジェントテーブルにはフェイルセーフ期間がありませんが、デフォルトで1日のタイムトラベルが付属しています。ユーザーはタイムトラベルを0に設定してオフにすることができますが、Enterpriseプランでも1を超えて延長することはできません。</p>

        <p>トランジェントテーブルは、ステージングテーブルの場合のように、バックアップとリカバリが高い優先度ではない場合に適しています。開発環境とテスト環境でも同じことが言え、トランジェントのデフォルトはスキーマとデータベースレベルで設定できます（この章の後半で説明）。</p>

        <p>トランジェントテーブルを作成するコマンドは次のとおりです：</p>

        <pre><code>CREATE TRANSIENT TABLE &lt;table_name&gt;</code></pre>

        <p>トランジェントテーブルはデータのステージングと開発環境に理想的ですが、Snowflakeはユーザーセッションの期間中のみ存続するテンポラリーテーブルタイプも提供しています。</p>

        <h4>テンポラリーテーブル</h4>

        <p>テンポラリーテーブルのデータ保持プロパティは、1つの重要な違いを除いて、トランジェントテーブルのものと同じです：テンポラリーテーブルはユーザーセッションの終了時に削除されます。セッションはアクティブなログインと考えることができます。複数のセッション（複数のワークシートを使用する場合など）を並行して実行できますが、それらはすべて接続またはログインとともに終了します。</p>

        <p>その一時的な性質により、テンポラリーテーブルは同じセッション中のプロセスの中間結果を保持することを目的としています。テンポラリーテーブルは、開発環境での使い捨てテストにも使用でき、ユーザーが明示的に削除する手間を省くことができます。</p>

        <p>テンポラリーテーブルを作成するコマンドは次のとおりです：</p>

        <pre><code>CREATE TEMPORARY TABLE &lt;table_name&gt;</code></pre>

        <div class="info-box">
            <h4>テンポラリーテーブルの命名に関する注意</h4>
            <p>テンポラリーテーブルはすべてのデータベースオブジェクトと同様にスキーマに割り当てる必要がありますが、セッションベースの永続性により、他のテーブルタイプとの一意性の衝突から免除されます。テンポラリーテーブルは非テンポラリーテーブルと同じ名前を持つことができ、セッションの残りの期間中はそれよりも優先されます（それによって非テンポラリーテーブルを隠します）。</p>
        </div>

        <p>Snowflakeが提供する物理テーブルがもう1つあります。そのプロパティは、保持時間よりも、Snowflakeがサポートできるワークロードのタイプに対する完全なゲームチェンジャーであることに関係しています。ハイブリッドUnistoreテーブルについて話しています。</p>

        <h4>ハイブリッドUnistoreテーブル</h4>

        <p>Snowflakeは2022年のサミットでハイブリッドUnistoreテーブルを発表し、現在アクセスのためのプライベートプレビューを提供しています。2023年にGAにリリースされる可能性が高いため、解き放たれる予定のゲームを変える可能性を期待して、ここに含まれています。</p>

        <p>SnowflakeのハイブリッドテーブルはSnowflakeのハイブリッドテーブルは、単一のセマンティックオブジェクトの下で透過的に管理される2つのテーブルです。ハイブリッドテーブルは、標準的な（パーマネント）OLAPテーブルと、Snowflakeサービスレイヤーが同期的かつ透過的に管理するOLTPテーブルで構成されています。OLAPとOLTPの組み合わせは、ハイブリッドトランザクション分析処理（HTAP）として知られており、両方の世界の最良のものを提供します。</p>

        <p>OLAPテーブルは、前述のパーマネントテーブルの標準的な列形式を使用し、Snowflakeが知られているすべての分析パフォーマンス機能を提供します。OLTPテーブルは、OLAPテーブルには見られない独占的な機能を提供します。次の章でより詳しく説明されるこれらの機能には、以下が含まれます：</p>

        <ul>
            <li>制約の強制</li>
            <li>インデックスのサポート</li>
            <li>変更と更新のための行レベルロック</li>
        </ul>

        <p>データがハイブリッドテーブルにロードされると、SnowflakeはOLAPテーブルとOLTPテーブルを同期的に更新します。その後、クエリオプティマイザーは、DMLまたはDQLクエリを、必要な操作に最適なテーブルにリダイレクトします。</p>

        <p>ハイブリッドテーブルの完全なドキュメントは公開されていませんが、CREATEコマンドは共有されており、制約を宣言するための既存の構文を使用します。ここに示すように：</p>

        <pre><code>CREATE HYBRID TABLE &lt;table_name&gt;</code></pre>

        <p>テーブルの適切なバックアップとワークロードを選択する柔軟性に関して、Snowflakeはユーザーに多くの選択肢を提供します。物理テーブルタイプとそのプロパティを要約しましょう。</p>

        <h4>テーブルタイプの要約</h4>

        <p>Snowflakeは、テーブルと保持期間に関して、ユーザーに多くの選択肢を提供します。3つの物理OLAPスタイルテーブルと新しく発表されたハイブリッドHTAPテーブルに精通したので、単一のチャートでそれらのプロパティを要約する価値があります。</p>

        <figure>
            <img src="../images/chapter4/B19467_04_003.jpg" alt="図4.3 – パーマネントテーブルの保持期間" style="max-width: 100%; height: auto;">
            <figcaption>図4.3 – パーマネントテーブルの保持期間</figcaption>
        </figure>

        <p>タイムトラベルとリカバリについて詳しく説明しましたが、物理テーブルに対して別のタイプの履歴も有効にできることに言及する価値があります：変更履歴です。ユーザーがテーブルの履歴スナップショットにアクセスできるようにするタイムトラベルとは異なり、変更履歴は個々のテーブルの変更を記録し、変更データキャプチャ（CDC）を可能にします。この機能については、この章の後半でより詳しく説明します。</p>

        <p>物理テーブルは、Snowflakeユーザーが情報の保存と操作のために最も頻繁にやり取りするものですが、他のタイプのテーブルも定義できます。外部テーブルとディレクトリテーブル（ステージオブジェクト上のメタデータテーブル）は、作成してリレーショナルにモデル化できます。これらのメタデータオブジェクトをより詳しく探りましょう。</p>

        <h3>ステージメタデータテーブル</h3>

        <p>外部テーブルとディレクトリテーブルは、通常のテーブルから選択するかのように、ユーザーがステージングされたファイルのデータにアクセスできるようにするためにSnowflakeに存在します。外部テーブルは、主キーと外部キーを許可し、標準的なリレーショナルコンテキストでモデル化できるため、このセクションで言及されています。ディレクトリテーブルは外部テーブルに似ていますが、列または制約の作成を許可せず、完全性のために含まれています。</p>

        <h4>外部テーブル</h4>

        <p>外部テーブルは、ステージの上に作成されたメタデータオブジェクトで、ユーザーが外部にステージングされたファイルのデータをデータベース内にあるかのようにクエリできるようにします。ステージでサポートされているのと同じファイルフォーマットが、外部テーブルを通じてデータにアクセスするためにサポートされています。すべての外部テーブルに次の列が含まれています：</p>

        <ul>
            <li><strong>VALUE</strong>：外部ファイルの単一行を表すVARIANT型の列</li>
            <li><strong>METADATA$FILENAME</strong>：外部テーブル内の各ステージングされたデータファイルの名前を識別します（ステージ内のパスを含む）</li>
            <li><strong>METADATA$FILE_ROW_NUMBER</strong>：ステージングされたデータファイル内の各レコードの行番号を表示します</li>
        </ul>

        <p>読み取り専用ですが、外部テーブルでは、ユーザーがVALUEまたはMETADATA列に対する式として仮想列を作成できます。外部テーブルを通じてデータをクエリすることは、ネイティブテーブルよりも遅い可能性があります。データソースとして依存するのではなく、ファイルの内容やメタデータを覗き見るために使用する必要があります。</p>

        <p>外部テーブルを作成するには、次のコマンドを使用します：</p>

        <pre><code>CREATE EXTERNAL TABLE &lt;table_name&gt;</code></pre>

        <p>外部テーブルを使用すると、ユーザーは通常のテーブルに保存されているかのように、ステージングされたファイルの内容にアクセスできます。ただし、ファイルディレクトリ情報のみが必要な場合は、ディレクトリテーブルを使用できます。</p>

        <h4>ディレクトリテーブル</h4>

        <p>概念的には、ディレクトリテーブルは外部テーブルに似ています。ただし、いくつかの注目すべき違いがあります。外部テーブルとは対照的に、ディレクトリテーブルには次の違いがあります：</p>

        <ul>
            <li>別個のデータベースオブジェクトではなく、ステージの一部として有効にできます</li>
            <li>ファイルの内容ではなく、パス、サイズ、URLなどのファイルメタデータを提供します</li>
            <li>仮想列（または制約）の作成を許可しません</li>
            <li>内部および外部の両方のステージで作成できます</li>
        </ul>

        <p>外部テーブルは、通常の物理テーブルと同じ規則を使用して、外部クラウドストレージに保存されたデータにアクセスすることを許可しますが、ディレクトリテーブルはファイルメタデータのみを表示します。ディレクトリテーブルは、実際のテーブルよりも、ステージからファイルのリストを返すLIST関数に似ています。LIST関数の代わりにディレクトリテーブルを使用すると、ユーザーは馴染みのあるSELECT構文を使用して情報にアクセスできます。</p>

        <p>次のコマンドは、ディレクトリテーブルを作成する方法を示しています：</p>

        <pre><code>CREATE STAGE &lt;stage_name&gt;
...
DIRECTORY = (ENABLE = TRUE);</code></pre>

        <p>Snowflakeテーブルのすべての形態をカバーしたので、ビューを見てみましょう。</p>

        <h2>Snowflakeビュー</h2>

        <p>Snowflakeビューは、ほとんどのリレーショナルデータベースと同様に動作します。物理オブジェクトに対するSELECTステートメントをスキーマ内のオブジェクトとして保存します。共有可能なデータベースオブジェクトとしてSELECTステートメントを保存することは、システムのユーザーにいくつかの利点を提供します：</p>

        <ul>
            <li>SELECTステートメントは、必要になるたびに最初から書き直す必要がありません。これにより、データパイプラインと分析のための再利用可能なモジュラーコードを通じて、時間の節約と保守性の利点が得られます。</li>
            <li>ビューにアクセスできるすべての人にとって、フィルターとビジネスロジックの一貫性。</li>
            <li>ビューは、参照するデータソースとは別のデータベースオブジェクトであるため、基礎となるすべてのデータを公開しない異なる権限を持つことができます。</li>
            <li>一度に複数のソースからデータを選択できます。</li>
            <li>ビューを更新する必要なく、ソーステーブルから最新のデータを常に表示します（結果を物理テーブルとして具体化するのとは対照的に）。</li>
            <li>データは物理的にコピーされず、ビューが呼び出されたときにリアルタイムで読み取られるため、ストレージコストはゼロです。</li>
        </ul>

        <p>ビューを作成するには、次のコマンドを使用します：</p>

        <pre><code>CREATE VIEW &lt;view_name&gt;</code></pre>

        <p>これらの利点は、パフォーマンスという単一のトレードオフを犠牲にしてもたらされます。ビューが呼び出されるたびに、基礎となるテーブルからデータを読み取る必要があり、ビュー内のすべてのロジックと数式がコンピュートリソースを使用して計算され、クレジットを消費します。ただし、前の章で説明したSnowflakeのキャッシング機能もビューで機能することを考慮すると、これはそれほど心配するほどのことではありません。</p>

        <h3>キャッシング</h3>

        <p>ビューは、ユーザークエリを実行する際のパフォーマンスとコストの問題を軽減するために、Snowflakeのさまざまなキャッシュを活用しようとします。</p>

        <p>サービスレイヤーによって管理される結果キャッシュには、ビューで実行されたクエリを含む、システム内のすべてのクエリ結果が保持されます。基礎となるデータが変更されていない限り、後続のクエリは、構文的に同等である場合、コンピュートクレジットを使用せずにキャッシュから結果を即座に返します。</p>

        <p>結果キャッシュを使用できない場合、Snowflakeはビューを通じてテーブルデータを参照する際にウェアハウスキャッシュを活用しようとします。クラウドストレージから読み取られたテーブルデータは、ウェアハウスがアクティブである限り、ウェアハウスキャッシュを通じてメモリで利用可能になり、それにアクセスするビューのデータ取得時間を短縮します。</p>

        <h3>セキュリティ</h3>

        <p>前述のように、ビューはスタンドアロンのセキュアなデータベースオブジェクトであるため、データセキュリティを強化するために使用できます。機密データを含むテーブルは、行レベルまたは列レベルのいずれかで、ビューを通じてパブリックアクセスから制限できます。ビューは、選択される列とフィルターを制限でき、個別のアクセスロールを割り当てることができます。</p>

        <p>Snowflakeユーザーは、セキュアビューを使用することで、追加レベルのセキュリティにアクセスできます。セキュアビュー（通常のビューのように宣言されますが、CREATEステートメントにsecureという単語が含まれます）は、ビュー定義（DDL）がコンシューマーには表示されず、ビューを所有するロールにのみ表示されることを除いて、非セキュア（通常の）ビューのように機能します。基礎となるデータを公開しないように、セキュアビューではいくつかの内部最適化が無効になっていますが、パフォーマンスは一般的に非セキュアビューと同等です。</p>

        <p>次のコマンドはセキュアビューを作成します：</p>

        <pre><code>CREATE SECURE VIEW &lt;view_name&gt;</code></pre>

        <p>テーブルとビューを理解したので、これら2つのオブジェクトタイプの両方から利点を提供するSnowflakeオブジェクトであるマテリアライズドビューについて理解しましょう。</p>

        <h2>マテリアライズドビュー</h2>

        <p>正確にはビューではなく、かといってテーブルでもないマテリアライズドビューは、これら2つのオブジェクトタイプの交差点に位置し、1つの重要な注意点とともに興味深い利点を提供します。</p>

        <p>名前が示すように、マテリアライズドビューは実際にはビューの結果を保存する物理テーブルです。基礎となるデータが変更されると、結果は自動的に再マテリアライズされます。これは、マテリアライズドビューが、キャッシュされたクエリ結果と組み合わせたテーブルのパフォーマンスを提供しながら、通常のビューのすべてのセキュリティ上の利点を提供することを意味します。</p>

        <p>唯一のトレードオフはコストです。マテリアライズドビューはクエリ結果を物理テーブルに保存するため、関連するストレージコストが発生します。さらに、マテリアライズドビューはデータを更新する際にクレジットを使用します。</p>

        <p>マテリアライズドビューには、通常のビューと比較して、SELECTステートメントで許可するロジックに特定の制限があります。その中でも主なものは、マテリアライズドビューは単一のデータソース（ステージは許可されています）上にのみ構築できるため、結合を使用できないことです。この制限により、マテリアライズドビューのユースケースは、事前計算されたテーブル結果または集計のユースケースに縮小されます。プラス面として、Snowflakeオプティマイザーは、可能な限りテーブルクエリをマテリアライズドビューに自動的にリダイレクトするほど賢いです。</p>

        <p>Snowflakeユーザーは、次の条件がすべて満たされている場合はマテリアライズドビューを検討する必要がありますが、いずれかが満たされていない場合は割引する必要があります：</p>

        <ul>
            <li>クエリ結果が頻繁に変更されない</li>
            <li>ビュー結果は、データの変更が発生するよりもはるかに頻繁に使用される</li>
            <li>クエリは多くのコンピュートリソースを消費する</li>
        </ul>

        <p>マテリアライズドビューを作成するには、次のコマンドを使用します：</p>

        <pre><code>CREATE MATERIALIZED VIEW &lt;view_name&gt;</code></pre>

        <p>Snowflakeのさまざまなデータソースオプションをカバーしたので、それらのデータ変更を検出し、それらの間の変換パイプラインを自動化することに焦点を当てましょう。</p>

        <h2>ストリーム</h2>

        <p>ストリームは、前述のオブジェクト（物理テーブル、ビュー、外部テーブル、ディレクトリテーブル）を含む基礎となるソースのデータ変更をキャプチャする論理オブジェクトです。ソースオブジェクトでDML操作が発生するたびに、ストリームは変更（挿入、削除、更新の前後のイメージ）を追跡します。ストリームは、オフセットストレージ技術を通じてこれを実現します。論理的にデータの初期スナップショットを取得し、メタデータ列を通じて変更を追跡します。ストリームはテーブルのようにクエリできますが、別個のオブジェクトではなく、テーブルデータを含みません。</p>

        <p>ストリームが作成されると、メタデータ列がソースオブジェクトに追加され、変更の追跡を開始します。次の表は、メタデータフィールドとその内容を説明しています：</p>

        <figure>
            <img src="../images/chapter4/B19467_04_004.jpg" alt="図4.4 – ストリームメタデータ列" style="max-width: 100%; height: auto;">
            <figcaption>図4.4 – ストリームメタデータ列</figcaption>
        </figure>

        <p>次のコマンドは、テーブル上にストリームを作成します：</p>

        <pre><code>CREATE STREAM &lt;stream_name&gt; ON TABLE &lt;table_name&gt;</code></pre>

        <p>後続のDML操作ごとに、ストリームは変更されたレコードの前後のイメージを保持し、DML操作のタイプ（挿入、更新、または削除）を識別する関連メタデータとペアリングすることで、ダウンストリームオブジェクトへの正確なCDCを可能にします。</p>

        <h3>ストリームからのロード</h3>

        <p>Snowflakeは、エレガントな消費方法を通じてストリームを管理可能に保ち、過度に成長することを防ぎます。消費（ストリームコンテンツを使用してダウンストリームソースを（正常に）ロードまたは更新すること）により、ストリームが空になり、手動の定期的なプルーニングを必要とせずに将来のDML変更を吸収する準備が整います。選択と失敗した消費の試みは、ストリームをクリアしません。</p>

        <p>次の図では、さまざまなDML操作にわたって実際にどのように機能するかを見てみましょう。この例では、ソーステーブルへの各変更後にストリームが消費（空にされる）されることを前提としています。</p>

        <figure>
            <img src="../images/chapter4/B19467_04_005.jpg" alt="図4.5 – テーブル変更後のストリームからのデータ消費" style="max-width: 100%; height: auto;">
            <figcaption>図4.5 – テーブル変更後のストリームからのデータ消費</figcaption>
        </figure>

        <p>追跡されるデータの性質に応じて、ストリームは2つの種類で利用できます：</p>

        <ul>
            <li><strong>標準（またはデルタ）</strong>：挿入、削除、および更新を記録します。このタイプのストリームは、テーブル、ディレクトリテーブル、およびビューでサポートされています。</li>
            <li><strong>追加/挿入のみ</strong>：挿入されたレコードのみを追跡し、更新または削除を無視します。このストリームタイプは、物理テーブル、ディレクトリテーブル、およびビューで追加のみとしてサポートされ、外部テーブルでは挿入のみとしてサポートされます。</li>
        </ul>

        <p>手動でバージョンを追跡および比較することに関連する処理オーバーヘッドなしに変更を追跡できることは、更新する必要がある変更のタイプを予測することで、ダウンストリームDML操作を簡素化します。このため、ストリームは、ファクトテーブルとゆっくり変化するディメンション（SCD）をモデリングし、それらを最新の状態に保つ際に頻繁に使用されます（これらのオブジェクトとそれらを維持するために使用される技術については、後の章で説明されます）。</p>

        <p>ストリームは定期的に消費されることを意図しています。ストリーム内の変更のデフォルトの保持期間は14日です。これは延長できますが、Snowflakeはその期間を超えてストリームの鮮度を保証できません。ただし、消費されても消えない、より揮発性の低い代替手段があります。</p>

        <p>次のセクションでは、変更追跡と、CDCのストリームと組み合わせて、またはストリームの代替として使用する方法について説明します。</p>

        <h3>変更追跡</h3>

        <p>ストリームはスキーマ内のスタンドアロンオブジェクトとして作成されますが、変更追跡はテーブルで直接有効になり、SnowflakeユーザーがCDCメタデータをクエリできるようにします。変更追跡は、ストリームで見つかるのと同じメタデータフィールドを使用しますが、それらをテーブルに直接追加します。ストリームとは異なり、変更がダウンストリームオブジェクトの更新に使用されても削除されません。代わりに、変更追跡はテーブルのデータ保持時間の間持続します。</p>

        <p>ここに、テーブルで変更追跡を有効にしてクエリする方法の例があります。この例では、3つのレコードが変更追跡対応テーブルに挿入されます。その後、1つのレコードが更新され、別のレコードが削除されます：</p>

        <pre><code>create or replace table myTable (
   myTable_id varchar(10),
   my_date date
);
-- 変更追跡を有効にする
alter table myTable set change_tracking = true;
-- 現在のタイムスタンプのセッション変数を初期化
set cDts  = (select current_timestamp());
set cDate = (select current_date());
-- DMLを実行
insert into myTable (myTable_id,my_date)  values
('yesterday', $cDate-1 ),
('today'    , $cDate+0 ),
('tomorrow' , $cDate+1 );
delete from myTable where myTable_id = 'yesterday';
update myTable set my_date = '1970-01-01'
where myTable_id = 'today';
-- 変更追跡メタデータをクエリして、タイムスタンプから現在までの差分を確認
select * from myTable
changes(information => default)
at(timestamp => $cDts);</code></pre>

        <p>テーブルの変更ログのクエリから返される結果は、レコードの累積効果（最新バージョン）を示しています。yesterdayとtodayのレコードは、タイムスタンプが設定される前に存在しなかったため、結果には存在しないことに注意してください。</p>

        <figure>
            <img src="../images/chapter4/B19467_04_006.jpg" alt="図4.6 – デフォルトのテーブル変更追跡からのクエリ結果" style="max-width: 100%; height: auto;">
            <figcaption>図4.6 – デフォルトのテーブル変更追跡からのクエリ結果</figcaption>
        </figure>

        <p>しかし、同じ変更ログが追加のみモードでクエリされたときに何が起こるかを見てください：</p>

        <pre><code>-- 変更追跡メタデータをクエリして、タイムスタンプから現在までの挿入のみを確認
select * from myTable
changes(information => append_only)
at(timestamp => $cDts);</code></pre>

        <p>結果は、後続の削除または更新に関係なく、テーブルに挿入されたレコードのみを返します。todayとtomorrowの両方のレコードが返されるのに対し、更新であったgood dayは存在しないことに注意してください。</p>

        <figure>
            <img src="../images/chapter4/B19467_04_007.jpg" alt="図4.7 – 追加のみモードでのテーブル変更追跡からのクエリ結果" style="max-width: 100%; height: auto;">
            <figcaption>図4.7 – 追加のみモードでのテーブル変更追跡からのクエリ結果</figcaption>
        </figure>

        <p>いくつかの制限を除いて、基礎となるテーブルで有効になっている限り、ビューに対しても変更追跡を有効にできます。変更追跡メタデータはテーブルのデータ保持期間全体にわたって持続し、消費時にクリアできないため、自動化されたCDCパイプラインには適していませんが、変更自体を分析するのに適しています。</p>

        <p>自動化されたデータパイプラインといえば、この章で取り組む最後のオブジェクトは、この重要なタスクを処理するように設計されており、ストリームとCDC検出と非常にうまく連携します。</p>

        <h2>タスク</h2>

        <p>Snowflakeはタスクを使用して、データのロードと変換をスケジュールおよび自動化します。データの移動はリレーショナルモデリングでは追跡されませんが、変換モデリングの不可欠な部分であり、完全性のためにここでカバーされています。</p>

        <p>タスクは、SQLをシリアルまたは並列ステップで実行することにより、データパイプラインを自動化します。タスクをストリームと組み合わせて、最近変更されたテーブル行を処理する継続的なELTワークフローにすることができます。これは、サーバーレスで（アクティブなウェアハウスを必要としない自動スケーラブルなSnowflake管理コンピュートクラスターを使用して）、または専用のユーザー定義ウェアハウスを使用して実行できます。</p>

        <p>タスクを作成するコードは次のとおりです：</p>

        <pre><code>CREATE TASK &lt;task_name&gt;
...
[ AFTER &lt;parent_task_1&gt; [ , &lt;parent_task_2&gt; , ... ] ]
[ WHEN &lt;boolean_expr&gt; ]
AS &lt;sql&gt;</code></pre>

        <p>タスクは理解しやすいです。スケジュールに従って、または親タスクの一部として呼び出されたときに、SQLコマンドを実行します（またはストアドプロシージャを実行します）。次の図は、タスクをシリアルおよび並列にチェーンして、データパイプラインの依存関係を形成する方法を示しています。</p>

        <figure>
            <img src="../images/chapter4/B19467_04_008.jpg" alt="図4.8 – シリアルおよび並列依存関係を持つタスクツリー" style="max-width: 100%; height: auto;">
            <figcaption>図4.8 – シリアルおよび並列依存関係を持つタスクツリー</figcaption>
        </figure>

        <div class="info-box">
            <h4>ストアドプロシージャとスクリプティング</h4>
            <p>ストアドプロシージャとSnowflakeスクリプティングを使用すると、ループと分岐構造を使用して手続き型コードを記述でき、この本のコンテキストの外にあります。手続き型ロジックの操作に関する情報については、ストアドプロシージャに関するSnowflakeドキュメント（https://docs.snowflake.com/en/sql-reference/stored-procedures.html）およびSnowflakeスクリプティング（https://docs.snowflake.com/en/developer-guide/snowflake-scripting/index.html）を参照してください。</p>
        </div>

        <p>タスクをチェーンしてSnowflake内でデータパイプラインを形成する方法を理解したので、ストリームと組み合わせることでさらに進めることができます。</p>

        <h3>タスクとストリームの組み合わせ</h3>

        <p>タスクはストリームとうまくペアリングでき、実行前に変更をチェックできます。定義の一部として、タスクにはWHEN &lt;boolean_expr&gt;句があり、実行前に満たす必要がある論理条件を設定します。条件はブール値を返す必要がありますが、ユーザーが望む任意の関数またはサブセレクトを実行できます。適切に、ストリームにはCDCレコードが存在する場合は常にTRUEの値を返し、そうでない場合はFALSEを返すシステム関数が付属しています。この関数は、ストリーム名を参照して次のように呼び出すことができます：</p>

        <pre><code>SYSTEM$STREAM_HAS_DATA('&lt;stream_name&gt;')</code></pre>

        <p>タスクの開始時にこの条件を設定すると、変更が予想される頻度で実行するようにスケジュールできますが、処理するレコードがある場合にのみ実行されます。</p>

        <p>この章で学んだことを要約しましょう。</p>

        <h2>まとめ</h2>

        <p>この章では、Snowflakeオブジェクトがテーブルやビューなどの馴染みのあるものの背後にも多くの機能を詰め込んでいることを示しました。Snowflakeのテーブルは、データだけでなく、設定に応じて、数か月の履歴と災害復旧バックアップを保持し、CDCのオフセット変更追跡を提供できます。同様に、ビューは期待を超えて、変更追跡と自動再マテリアライゼーションを提供します。</p>

        <p>ステージが外部ソースからSnowflakeテーブルへのデータのエントリポイントをマークする方法を見ました。ステージは、テーブルに事前にコピーすることなくファイルの内容を読み取るための外部テーブルアクセスなどの役立つ機能も提供します。</p>

        <p>最後に、受信データを調整し、自動化されたELTパイプラインを確立し、CDCを合理化するために、Snowflakeはタスクとストリームをペアリングして、ユーザーに完全なサーバーレスまたは管理された制御を提供します。ステージ、テーブル、ビュー、およびすべての接続変換ロジックを結び付けます。</p>

        <p>各オブジェクトの強みと機能を理解したので、次の章では、データモデリングの構成要素について説明し、それらをSnowflakeオブジェクトの対応物（列、テーブル、制約など）に結び付けます。これらの基本は、本書の後半で4つのモデリングタイプのそれぞれを詳細に探求するための基礎を築きます。</p>

        <h2>参考文献</h2>

        <p>追加情報については、次のリソースを参照できます：</p>

        <ul>
            <li>Understanding & Using Time Travel (Snowflakeドキュメント): https://docs.snowflake.com/en/user-guide/data-time-travel.html. 2022年11月16日アクセス。</li>
        </ul>

        <div class="nav-links">
            <a href="chapter3.html">← 第3章：Snowflakeのアーキテクチャをマスターする</a>
            <a href="chapter5.html" style="float: right;">第5章：Snowflakeオブジェクトを通じたモデリング →</a>
        </div>

        <footer>
            <p>&copy; 2024 SnowflakeによるデータモデリングLab. このコンテンツは個人学習用です。</p>
        </footer>
    </div>
</body>
</html>