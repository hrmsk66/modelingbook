<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noodp, noimageindex">
    <meta name="googlebot" content="noindex, nofollow">
    <title>第3章：Snowflakeのアーキテクチャをマスターする - SnowflakeによるデータモデリングLab</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <nav>
        <ul>
            <li><a href="../index.html">ホーム</a></li>
            <li><a href="../preface.html">はじめに</a></li>
            <li><a href="index.html">第1部</a></li>
        </ul>
    </nav>

    <div class="container">

        <h1>第3章：Snowflakeのアーキテクチャをマスターする</h1>
        
        <div class="notice">
            <div class="notice-title">📖 この章について</div>
            <p>この内容は「Data Modeling with Snowflake」の第3章を、省略することなく完全に日本語に翻訳したものです。</p>
        </div>

        <p>データベースが存在する限り、データ量と処理要求の増大に直面して、同時実行性とスケーラビリティの管理という再発する課題に直面してきました。長年にわたって多くの革新的な設計が試みられ、さまざまな程度の成功を収めてきました。しかし、その成功にはしばしば新たな欠点が伴いました。</p>

        <p>Snowflakeチームは、データストレージと分析の独立した消費要求に対処するという古くからの課題を克服するには、根本的に新しいアプローチが必要であることを認識しました。チームは、クラウドコンピューティングプラットフォーム上でネイティブに動作し、それによってほぼ無限のスケーラビリティを提供できるデータベースを設計することを決定しました。彼らの努力の結果、Snowflakeが「Data Cloud」と呼ぶものが生まれました。これは、ストレージとコンピュートの分離を通じて、リアルタイムのデータ共有とオンデマンドのワークロードサイジングを可能にするプラットフォームです。</p>

        <h2>この章では、以下のトピックを扱います：</h2>

        <ul>
            <li>データベースが過去にデータベースのスケーラビリティを達成しようとした方法を探る</li>
            <li>Snowflakeがクラウドでネイティブに実行されるスケーラブルなデータベースをどのように構築したかを発見する</li>
            <li>Snowflakeの革新的なアーキテクチャによって可能になった独自の機能を見る</li>
            <li>Snowflakeの変動支出モードに関連するコストを理解する</li>
            <li>コストを節約し、パフォーマンスを向上させるためにさまざまな形式のキャッシュを活用する方法を学ぶ</li>
        </ul>

        <p>Snowflakeが達成したことを真に評価するには、それ以前のさまざまな従来のアーキテクチャと、それらが克服しようとした制限を思い出す価値があります。</p>

        <h2>従来のアーキテクチャ</h2>

        <p>Snowflake Data Cloudの革新性を評価するには、一歩下がって、その前身に関連する設計と制限を思い出す必要があります。クラウドが登場するずっと前から、データベースは物理的なオンプレミスアプライアンスとして始まり、その開始以来、すべて同じ課題に直面してきました：スケーラビリティです。</p>

        <p>過去において、データベースは物理サーバーに限定されており、ストレージと処理能力をそれに依存していました。使用量が増加すると、メモリがいっぱいになり、CPU需要が利用可能な限界に達し、ユーザーはサーバーにより多くのリソースを追加するか、まったく新しいものを購入することを余儀なくされました。どちらの対応もメンテナンスとダウンタイムを伴うため、ハードウェアの購入は将来を見据えたものでなければならず、データベースの成長を数年先まで予測する必要がありました。</p>

        <p>次の図は、従来のデータベースの構造と主要な要素を概説しています。処理能力、メモリ、ディスクスペースはすべてある程度カスタマイズ可能でしたが、スケールできない物理マシンにパッケージ化されていました。</p>

        <figure>
            <img src="../images/chapter3/B19467_03_001.jpg" alt="図3.1 – 典型的なオンプレミスデータベースサーバーの図" style="max-width: 100%; height: auto;">
            <figcaption>図3.1 – 典型的なオンプレミスデータベースサーバーの図</figcaption>
        </figure>

        <p>クラウドアーキテクチャがSaaS（Software as a Service）モデルを解き放ち、変動支出価格を導入する前は、ハードウェアの購入にはかなりの資本支出（CapEx）が必要でした。したがって、ハードウェアのサイジング（現在および将来のコンピューティングニーズの見積もり）には慎重な計画が必要です。保守的な見積もりは予想よりも早いアップグレードにつながり、過大な見積もりは最先端技術に高額を支払い、何年も先までその全潜在能力を使用しないことを意味しました。データ量とCPU需要はビジネスと同期的に成長する傾向がありましたが、ストレージまたはコンピュートの予測されない使用量のスパイクも一般的であり、同様の頭痛の種につながりました。それが、物理マシンのスケーリングの限界に対処するために、共有ディスクや共有なしなどの新しいアーキテクチャが登場した時です。</p>

        <p>まず、共有ディスクアーキテクチャが従来の設計に対してもたらした変更と、それが提供した利点を理解しましょう。</p>

        <h3>共有ディスクアーキテクチャ</h3>

        <p>共有ディスクアプローチは、中央ストレージロケーションを使用し、ネットワーク内のさまざまなコンピュートクラスターで利用できるようにします。これは、データを同時にロックしてアクセスする際に物理的な実装の問題に悩まされる単純な設計です。</p>

        <p>次の図は、共有ディスクアーキテクチャが個々のマシンからデータストレージを外部化し、ネットワーク上のすべてのコンピューティングクラスターがアクセスできるようにした方法を示しています。</p>

        <figure>
            <img src="../images/chapter3/B19467_03_002.jpg" alt="図3.2 – 共有ディスクアーキテクチャの図" style="max-width: 100%; height: auto;">
            <figcaption>図3.2 – 共有ディスクアーキテクチャの図</figcaption>
        </figure>

        <p>共有ディスク設計により、組織内のさまざまなワークロードに対応するために、さまざまなサイズのコンピュートクラスターを追加することが可能になりました。しかし、これは避けられないボトルネックにつながりました。共有ディスクアーキテクチャでネットワークに追加されるクラスターが多いほど、中央ディスクの競合が悪化します。この設計は、データベースの最も重要なリソースであるデータにボトルネックが発生したため、スケーラビリティの約束を果たすことができませんでした。</p>

        <p>共有ディスクが失敗したところで、共有なしはほぼ成功しました。</p>

        <h3>共有なしアーキテクチャ</h3>

        <p>AWS RedshiftやGreenplumで使用されているような共有なしアーキテクチャは、ディスクを分離してコンピュートクラスターの一部にすることで、共有ディスクの問題を回避しました。この設計は、組織全体のチームのさまざまな消費ニーズにも対処し、需要に基づいてデータベースクラスターのサイズを調整できるようにしました。しかし、小学校で学ぶように、何も共有しないことはコラボレーションにとって最良の戦略ではありません。</p>

        <p>次の図は、共有なしアーキテクチャが自給自足で孤立したデータベースクラスターを可能にする方法を示しています。</p>

        <figure>
            <img src="../images/chapter3/B19467_03_003.jpg" alt="図3.3 – 共有なしアーキテクチャのコンポーネント" style="max-width: 100%; height: auto;">
            <figcaption>図3.3 – 共有なしアーキテクチャのコンポーネント</figcaption>
        </figure>

        <p>共有なしアーキテクチャでデータベースクラスターを作成すること、特に仮想クラウドリソースで実行されるものは、物理ハードウェアへの事前投資の問題を解決します。しかし、共有なしアーキテクチャのノードは情報を共有するためにデータ転送を必要とし、これがパフォーマンスにペナルティを与えます。</p>

        <p>ディスクを全体的なクラスターに結び付けることは、独立して変化する可能性のあるストレージと処理パターンの間で適切なバランスを取ることも意味します。重いデータサイエンスのワークロードは、比較的小さなデータセットに多くのコンピュートを向ける必要があるかもしれませんが、ETLバルクロードプロセスはその逆を必要とするかもしれません。しかし、共有なしプラットフォームは、各リソースを個別に調整するための多くのオプションを提供しておらず、メンテナンスと管理も簡単ではありませんでした。</p>

        <p>共有なしアーキテクチャは、シームレスで管理しやすいスケーラビリティの約束を完全には果たしませんでしたが、Snowflakeなどのプラットフォームがクラウドネイティブ設計でクラウドコンピューティングの課題に取り組む道を開きました。</p>

        <h2>Snowflakeのソリューション</h2>

        <p>データベースが誕生以来悩まされてきたスケーラビリティの問題に対処するため、Snowflakeチームは過去の設計の制限に縛られない新しいアプローチを策定することを決定しました。彼らは、クラウド専用にネイティブに構築された最新のプラットフォームを開発し、その独自の機能を使用して同時実行性、スケーラビリティ、リアルタイムコラボレーションを可能にしました。</p>

        <p>Snowflakeの革新的なクラウドアーキテクチャは依然として物理ディスクに依存していますが、それらを論理的に統合して、同時実行性のボトルネックやデータレプリケーションのオーバーヘッドなしに、中央集中型ストレージをコンピューティングクラスターで利用できるようにします。最終的に、共有ディスクと共有なしが約束したものの最良のもの：データをコンピュートワークロードから分離し、独立してプロビジョニングおよびサイズ変更できます。</p>

        <p>Snowflakeは、クラウドプラットフォーム（Amazon、Microsoft、Google Cloud）から仮想的にプロビジョニングされたリソース上で完全に実行されます。Snowflakeはクラウドプロバイダーとのすべての相互作用を透過的に処理し、基盤となる仮想リソースを抽象化し、顧客が統一された3層アーキテクチャを通じてデータを管理できるようにします。</p>

        <h3>Snowflakeの3層アーキテクチャ</h3>

        <p>Snowflakeアーキテクチャは、ストレージ、コンピュート、クラウドサービスの3つのレイヤーで構成されています。Snowflakeは3つのレイヤーすべてを管理するため、基盤となるクラウドアーキテクチャとの相互作用はユーザーに対して透過的です。</p>

        <p>以下は、Snowflakeのアーキテクチャがクラウドデータプラットフォーム上で実行され、ディスクを仮想コンピュートクラスターから分離しながら、別の運用サービスレイヤーを管理する方法（ユーザーが管理する必要がないように）を示す図です。</p>

        <figure>
            <img src="../images/chapter3/B19467_03_004.jpg" alt="図3.4 – Snowflakeハイブリッドクラウドアーキテクチャ" style="max-width: 100%; height: auto;">
            <figcaption>図3.4 – Snowflakeハイブリッドクラウドアーキテクチャ</figcaption>
        </figure>

        <p>では、ゼロコピークローンやタイムトラベルなどのSnowflakeの革新的な機能を可能にするために、それらがどのように組み合わされるかを説明する前に、3つのレイヤーそれぞれについて理解しましょう。</p>

        <h3>ストレージレイヤー</h3>

        <p>ストレージレイヤーは、Snowflakeアカウントをホストしているクラウドプロバイダーのディスクに物理的にデータを保存します。データがSnowflakeにロードされると、圧縮、暗号化され、テーブル、スキーマ、およびデータベースに論理的に編成されます。ユーザーはデータベースとそのオブジェクトの論理階層を定義し、Snowflakeは基盤となるパーティショニングとストレージを処理します。顧客は保存したデータに対してのみ課金され、プロビジョニングやサイジングは必要ありません。</p>

        <p>後の章では、Snowflakeがデータストレージを管理および最適化する方法と、提供するバックアップおよび冗長性オプションの種類について詳しく説明します。今のところ、Snowflakeでコンピュートと仮想ウェアハウスクラスターがどのように機能するかを理解しましょう。</p>

        <h3>コンピュートレイヤー</h3>

        <p>コンピュートレイヤー（処理レイヤーまたは仮想ウェアハウスレイヤーとも呼ばれる）は、クエリを実行するための仮想的にプロビジョニングされたCPUと一時メモリリソースのクラスターを提供します。これらのクラスターはウェアハウスと呼ばれ、XSから6XLベンチマークまでのTシャツサイズでプロビジョニングされます。ウェアハウスを通じて、Snowflakeは簡単な公式を使用して仮想クラウドリソースの消費を簡素化します。ウェアハウスサイズを増やすたびに、クラスター内の仮想サーバーの数が2倍になり、コストも2倍になります。</p>

        <p>仮想コンピュートクラスターをウェアハウスにパケット化し、シンプルなTシャツサイズを使用することで、基盤となるクラウドアーキテクチャを抽象化し、Snowflakeアカウントがホストされているプラットフォームに関係なく、シンプルで一貫した利用を保証します。このように、ウェアハウスは追跡しやすい方法でスケールできます。スケールアップ、つまりウェアハウスをTシャツサイズの次のサイズにリサイズすると、クラスター内のサーバー数が2倍になり、スケールアウトは同じサイズのウェアハウスをコンピュートクラスターに追加して同時実行性を高めます（スケールアップまたはスケールアウトは、それぞれコンピュート×2またはコンピュート+1と考えてください）。</p>

        <h3>サービスレイヤー</h3>

        <p>Snowflakeのサービスレイヤーは、このハイブリッドレイヤーモデルですべてのアカウントアクティビティを調整し、セキュリティから暗号化、メタデータまですべてを管理します。サービスレイヤーは、クエリの解析と最適化、データ共有、キャッシングなどの操作を処理します。ログインから、ユーザーがウェアハウスで実行するすべての操作を通じて、サービスレイヤーがユーザーのためにそこにあります。サービスレイヤーが提供する時間節約の作業と自動化の量は、Snowflakeのマーケティング言語に反映されています：ユーザーに低コストと卓越したパフォーマンスとともに、ほぼゼロのメンテナンスを約束します。</p>

        <p>それでは、Snowflakeの3層アーキテクチャがどのように組み合わさって、ユーザーに前例のない可能性を解き放つかを見てみましょう。</p>

        <h2>Snowflakeの機能</h2>

        <p>その革命的なクラウドアーキテクチャにより、Snowflakeは革新を続け、その開始から有名になったものを超えて、ゲームを変えるパフォーマンスの強化でユーザーを（楽しく）驚かせています。これは決して包括的なリストではありませんが、以下のセクションでは、データモデリングに関して最もエキサイティングで関連性の高い機能のいくつかを強調しています。</p>

        <h3>ゼロコピークローン</h3>

        <p>ゼロコピークローンにより、Snowflakeユーザーは物理的に複製することなくデータをクローンできます。データを移動する必要がないということは、テーブルをクローンする場合でもデータベース全体をクローンする場合でも、クローニングが瞬時に発生することを意味します。クローンされたオブジェクトはそのソースの仮想コピーであるため、ストレージコストは発生しません。クローンまたはそのソースでデータ変更が発生すると、クローンは物理オブジェクトになり、ストレージリソースの消費を開始します。</p>

        <p>クローニングは、システムバックアップとテスト環境を作成する理想的な方法であり、以前は数日かかっていたことを数秒で達成します。オブジェクトレベルでは、クローニングは開発またはデバッグ時に環境間でデータを持ち込む便利な方法です。</p>

        <p>革新的な列指向ストレージ技術（後の章で説明）によって可能になったもう1つの強化は、タイムトラベルです。</p>

        <h3>タイムトラベル</h3>

        <p>テスト環境だと思ってプロダクション環境でテーブルを削除する前のような、より良い瞬間に時間を戻る能力を想像してください。Snowflakeのタイムトラベルがそれを可能にします。</p>

        <p>タイムトラベルを使用すると、ユーザーは以前の時点からデータをクエリまたはクローンでき、ミスから回復したり、現在の状態からの変更を比較したりできます。タイムトラベルはSnowflakeオブジェクトの組み込みバックアップ機能であり、そのため、この機能が無効になっているオブジェクトと比較して追加のストレージを使用し、関連するストレージコストが発生します。後の章では、コストと柔軟性のバランスを取るためにタイムトラベルを構成する方法について説明します。</p>

        <p>さて、テーブルバックアップの代わりに、Snowflakeの最新の革新の1つを通じてテーブルを操作するまったく異なる方法に注目しましょう。</p>

        <h3>ハイブリッドUnistoreテーブル</h3>

        <p>データウェアハウスは、分析ワークロードが必要とする大規模な集計と計算を効率的に実行できるようにするために、オンライン分析処理（OLAP）アーキテクチャを実行します。ただし、単一行操作またはインデックスに依存するユースケースは、オンライントランザクション処理（OLTP）データベースでより良いパフォーマンスを発揮します。Snowflake Summit 2022で、ユーザーに両方の世界の最良のものを提供する新しい種類のテーブルが発表されました：ハイブリッドUnistoreです。</p>

        <p>ハイブリッドUnistoreテーブルは実際には1つで2つのテーブルです。分析テーブルとトランザクションテーブルが内部で連携して、両方の世界の最良のものを提供する統一されたソリューションをユーザーに提供します。すべてのSnowflakeオブジェクトと同様に、ハイブリッドテーブルは、サービスレイヤーがワークロードをタスクに最適な基盤となるテーブルに自動的にルーティングすることで、ほぼゼロのメンテナンスの約束を果たします。</p>

        <p>ハイブリッドUnistoreテーブルについては後の章で説明しますので、構造化データを超えて、Snowflakeのもう1つの強みについて説明しましょう。</p>

        <h3>構造化データを超えて</h3>

        <p>Snowflakeは、リレーショナルテーブルでのベンチマーク設定パフォーマンス能力と、半構造化データの操作における敏捷性で知られています。構造化されていないファイルも外部テーブルを通じてサポートされています。ユーザーは、テーブルをクエリするのと同じくらい馴染みがあり、パフォーマンスに優れた方法で、これらのファイル形式のいずれかを1つの場所から操作できます。</p>

        <p>JSONまたは同様の形式で保存されたログや階層などの半構造化ファイルは、Snowflakeにロードして、パフォーマンスにほとんど影響を与えることなく通常のテーブルのようにクエリできます。Snowflakeは、ユーザーが半構造化レコードを操作したり、それらを構造化列にフラット化したりできる広範な関数ライブラリを提供しています。これを行うための技術については、後の章で説明します。</p>

        <p>構造化されていないデータもサポートされており、（そのメタデータは）外部テーブルを通じてクエリできます。外部テーブルは、外部ステージの上に作成されたメタデータオブジェクトです。外部テーブルは読み取り専用ですが、リレーショナルモデリングの制約はサポートしています。外部テーブルの操作に関する追加情報は、こちらのSnowflakeドキュメントで見つけることができます：https://docs.snowflake.com/en/user-guide/tables-external-intro.html。</p>

        <p>これらすべての素晴らしい機能とクラウドの敏捷性は、相当な費用がかかるに違いないと思うでしょうか？実際には、前払い費用なし、競争力のある価格設定、およびユーザーのニーズに合わせてウェアハウスのサイズを調整したり、完全に一時停止したりする機能により、ユーザーはレガシーオンプレミスハードウェアよりもSnowflakeに費やす費用を少なくすることがよくあります。注意点は、そうするために、ユーザーはSnowflakeの価格設定がどのように機能し、それを効果的に管理する方法を理解する必要があることです。</p>

        <h2>考慮すべきコスト</h2>

        <p>前払いで購入し、ライフサイクルの期間中使用されるオンプレミスデータベースとは異なり、Snowflakeは変動支出（一般的に従量課金制と呼ばれる）として知られる消費ベースのモデルを採用しています。変動支出により、チームは前払い投資なしで迅速なプロトタイピングや概念実証の実験を行うことができ、使用パターンを監視および調整することでコストを制御できます。ここでは、後で情報に基づいた設計上の決定を下すことができるように、Snowflakeプラットフォームの使用に関連するコストの種類を分解します。</p>

        <p>クラウドにデータを保存するコストから始めましょう。</p>

        <h3>ストレージコスト</h3>

        <p>Snowflakeは、プラットフォームに保存されているデータの日次平均に基づいて顧客に請求します。Snowflakeのサービスレイヤーは最適なストレージのためにデータを自動的に圧縮するため、顧客はパフォーマンスを犠牲にすることなく、より低いストレージコストを享受できます。ただし、ストレージクォータにカウントされるのは生データだけではありません。タイムトラベルとフェイルセーフバックアップ（次の章で詳しく説明）も考慮する必要があります。</p>

        <p>それでは、データ処理のコストについて話しましょう。</p>

        <h3>コンピュートコスト</h3>

        <p>Snowflakeの消費は、使用される仮想ウェアハウスの数、実行時間、およびそのサイズに基づいて請求されます。アクティブなウェアハウスは秒単位で請求されます（最小60秒）。Snowflakeは、ウェアハウスの価格設定に関する計算を簡素化するために、クレジットと呼ばれる標準単位を使用します。</p>

        <p>クレジットの正確なコストは、クラウドプロバイダー、ホスティング地域、Snowflakeエディション（Standard、Enterprise、Business Critical、またはVPS）などの要因によって異なります。これらの変数が固定されると、クレジットは1時間実行される1つのXSウェアハウスに相当します。重要な考慮事項は、ウェアハウスがクエリを実行しているかどうかに関係なく、アクティブである限りクレジットを消費することです。効果的なコスト戦略では、ウェアハウスがいつインスタンス化され、シャットダウンされるか（自動再開と自動一時停止のオプションが利用可能）、および特定のワークロードに必要なサイズを考慮する必要があります。</p>

        <p>最後に、プラットフォームの実行と管理のコストがあります。</p>

        <h3>サービスコスト</h3>

        <p>サービスレイヤーは、アクセス制御やクエリ最適化などの重要な操作を管理します。ただし、自動（再）クラスタリング、ストリーミングデータのロード（Snowpipe）、レプリケーションなどの自動化されたサーバーレスタスクも実行します。テーブルメタデータのクエリ（count、sum、maxなど）、オブジェクトの作成、showやdescribeなどのコマンドを通じてオブジェクトメタデータを取得するなど、ユーザーが生成する多くのアクションは、サービスレイヤーによって処理され、アクティブなウェアハウスを必要としません。</p>

        <p>サービスレイヤーのコストは、日次ウェアハウス消費の10％を超えない限り、ウェアハウスクレジットに含まれます。サービスレイヤーの消費がウェアハウス支出の10％を超える場合、その操作は標準クレジットレート（つまり、XSまたは同等の1時間あたり1クレジット）で請求されます。</p>

        <p>Snowflakeのアーキテクチャの3つのレイヤーそれぞれに関連するコストをカバーしたので、Snowflakeのさまざまなキャッシュの使用方法を学ぶことで、これらのコストをどのように節約できるかについても説明する必要があります。</p>

        <h2>キャッシュを使用して現金を節約する</h2>

        <p>オンプレミスデータベースでは、非効率的な操作により実行時間が長くなりました。Snowflakeの変動支出モデルでは、その余分な時間は金銭的なペナルティと結びついています。効率的なSQLを書くことに加えて、Snowflakeユーザーは、事前計算された結果を活用できる場所を理解するために、サービスおよび仮想コンピュートレイヤーに関連するさまざまなキャッシュも理解する必要があります。Snowflakeキャッシングをしっかりと把握することで、モデリングとデータパイプラインの構築時の意思決定にも役立ちます。</p>

        <p>サービスレイヤーから始めて、管理し、ユーザーに提供するキャッシュに慣れましょう。</p>

        <h3>サービスレイヤー</h3>

        <p>サービスレイヤーは、メタデータとクエリ結果キャッシュの2種類のキャッシュを処理します。</p>

        <h4>メタデータキャッシュ</h4>

        <p>サービスレイヤーは、構造、行数、列ごとの個別値などのオブジェクトメタデータを管理します。関連するSQL関数またはSnowflake UIを通じてこのメタデータを確認しても、実行中のウェアハウスは必要なく、クレジットも消費されません。</p>

        <p>Snowflakeは、テーブルレベルでメタデータ（バイト単位のサイズ、作成日など）を保存し、テーブル内のすべてのマイクロパーティションの列について統計（カウント、最小/最大、nullカウントなど）を保持します。</p>

        <div class="info-box">
            <h4>マイクロパーティション</h4>
            <p>マイクロパーティションは、列方式で編成されたテーブル内の行のグループです。マイクロパーティションにより、数百万のマイクロパーティションで構成される可能性のある大規模なテーブルのきめ細かいプルーニングが可能になります。Snowflakeサービスレイヤーは、テーブルでDML操作が実行されると、マイクロパーティションを自動的に作成および管理します。マイクロパーティションとキャッシングについては後の章で詳しく説明しますが、詳細については、Snowflakeドキュメントの「マイクロパーティションとデータクラスタリング」を参照してください：https://docs.snowflake.com/en/user-guide/tables-clustering-micropartitions.html。</p>
        </div>

        <p>サービスレイヤーは、オブジェクトの定義と構造のメタデータも保存します。これには、データベースオブジェクトのDDLと、列リスト、データ型（ビューの場合も）、制約などの詳細が含まれます。DDLの詳細は、describeやget_ddlなどのSQL関数を通じて取得するか、INFORMATION_SCHEMAを直接クエリすることで取得できます。後者にはアクティブなウェアハウスが必要でクレジットを消費しますが、前者はサービスレイヤーによって自動的に処理されます。</p>

        <p>サービスレイヤーが管理するもう1つのキャッシュタイプは、クエリ結果キャッシュです。</p>

        <h4>クエリ結果キャッシュ</h4>

        <p>Snowflakeアカウントのすべてのクエリ結果は、サービスレイヤーによって24時間保持され、他のユーザーが再利用できます。キャッシュされた結果を参照すると、24時間のクロックがリセットされ、最大期間は31日間で、その後結果はパージされます。アクセス権限以外にも、キャッシュされた結果を再利用できるようにするための他の考慮事項があります。これらには次のものが含まれます：</p>

        <ul>
            <li>クエリは構文的に同等でなければならない</li>
            <li>current_date()などの動的関数が使用されていない</li>
            <li>基礎となるテーブルのデータが変更されていない</li>
            <li>ユーザーが基礎となるソースにアクセスするために必要な権限を持っている</li>
        </ul>

        <p>クエリキャッシュから結果を取得することは、再計算するよりも無限に好ましいです。なぜなら、操作は瞬時に発生し、コンピュートクレジットを消費しないからです。レガシーデータベースとは異なり、キャッシュがメモリ需要を満たすために犠牲になったり、クラスターが一時停止された場合に完全に失われたりする可能性がある場合、Snowflakeの結果キャッシュは、前述の条件でパージされるまで維持されます。</p>

        <p>結果キャッシュを理解することは、Snowflakeリソースを効率的に使用し、設計上の決定を下すために重要です。しかし、それはユーザーが活用できる唯一のキャッシュではありません。</p>

        <h3>ウェアハウスキャッシュ</h3>

        <p>仮想ウェアハウスが中央ストレージレイヤー（AWS S3バケット、Azureコンテナー、Googleストレージコンテナーなどの基盤となるクラウドストレージのリモートディスクと呼ばれる）からデータにアクセスすると、データはウェアハウスキャッシュ（SSDストレージを使用して実装）に読み込まれます。SSDストレージの量は、ウェアハウスのサイズによって異なります。</p>

        <p>SSDストレージからの読み取りは、リモートディスクからの読み取りよりも高速であり、クエリオプティマイザー（つまり、サービスレイヤー）は、リモートストレージにデフォルトする前にキャッシュの使用を試みます。ただし、サービスレイヤーキャッシュとは異なり、ウェアハウスキャッシュには2つの重要な違いがあります：キャッシュは特定のウェアハウスに固有であり、ウェアハウスを一時停止するとキャッシュがパージされます。</p>

        <p>このことを念頭に置いて、同じデータソースにアクセスするユーザーは、同じウェアハウスを共有することで恩恵を受けるでしょう。ただし、キャッシュを保持するためにウェアハウスをアクティブに保つために必要なクレジットと、リモートストレージから最初からデータを読み取るために必要なI/Oとの間でトレードオフを考慮する必要があります。</p>

        <p>クエリが前述のキャッシュのいずれにもヒットできない場合、Snowflakeは操作を実行するためにストレージレイヤーにアクセスする必要があります。</p>

        <h3>ストレージレイヤー</h3>

        <p>Snowflakeは、アカウントがホストされている基盤となるクラウドプラットフォームファイルシステムのリモートディスクにデータを保存します。リモートディスクからのデータの読み取りは、ウェアハウスキャッシュ（SSDドライブに保存）からの読み取りよりも効率が低く、事前計算された結果をフェッチするよりもはるかに効率が低くなります。ストレージレイヤーには、言うべきキャッシュはありません。キャッシュが存在しない場合の最後の手段です。</p>

        <p>この章で学んだことを要約しましょう。</p>

        <h2>まとめ</h2>

        <p>Snowflakeのハイブリッドクラウドネイティブ設計は、クラウド用に最初から構築されており、リアルタイムのデータ共有とオンデマンドのワークロードサイジングを可能にし、ユーザーに比類のない柔軟性を提供します。これにより、以前のデータベースアーキテクチャの多くのスケーラビリティの制限を克服しています。Snowflakeのアーキテクチャにより、組織間での地域やクラウドプロバイダー間での安全なデータ共有が、同じアカウント内のデータベース間と同じくらい迅速に可能になります。</p>

        <p>Snowflakeのクラウドアーキテクチャを構成する各レイヤー（ストレージ、コンピュート、サービス）を理解することで、ゼロコピークローン、タイムトラベル、ハイブリッドUnistore、ハイブリッドトランザクション/分析処理（HTAP）テーブルなどの強力な機能をどのように可能にし、半構造化および非構造化データとの相互作用への扉を開くかについての洞察を得ました。</p>

        <p>この章では、3つのアーキテクチャレイヤーそれぞれのコストと、それらをチェックする方法についても概説しました。さらに、Snowflakeのアーキテクチャ全体のさまざまなキャッシングメカニズムがどのように連携してコストを節約し、パフォーマンスを向上させるかについて説明しました。</p>

        <p>非常に多くの革命的な機能により、Snowflakeは自身を単なるデータベースではなく、Data Cloudと考えています。その機能が可能にするすべてのもの（データとアプリのマーケットプレイスなどのサービス）を考慮すると、新しい用語が必要だった理由は簡単にわかります。</p>

        <p>Snowflakeが内部でどのように動作するかを垣間見たので、今度はデータベースオブジェクトの内部動作をより深く理解する時です。次の章では、Snowflakeテーブルを見て、そのさまざまなタイプとパラメーター、およびデータソースとして使用でき、データベース設計の一部としてモデル化できる他のオブジェクトタイプを探ります。これらのオブジェクトとその独自の機能を理解することで、Snowflakeの武器庫で利用可能なすべてのツールを活用する、スケーラブルで効率的なデータベース設計をモデル化できるようになります。</p>

        <h2>参考文献</h2>

        <p>Snowflakeのすべての機能とオブジェクトタイプに関する決定版ガイド（タイトルにそう書いてあります！）として、この本でカバーされているモデリング関連のコンテンツを超えて、Joyce Avilaの優れた完全なリファレンスを検討してください：</p>

        <p>Avila, Joyce. <em>Snowflake: The Definitive Guide: Architecting, Designing, and Deploying on the Snowflake Data Cloud.</em> O'Reilly Media, 2022.</p>

        <div class="nav-links">
            <a href="chapter2.html">← 第2章：4つのモデリングタイプ入門</a>
            <a href="chapter4.html" style="float: right;">第4章：Snowflakeオブジェクトをマスターする →</a>
        </div>

        <footer>
            <p>&copy; 2024 SnowflakeによるデータモデリングLab. このコンテンツは個人学習用です。</p>
        </footer>
    </div>
</body>
</html>